{"version":3,"file":"vendors-node_modules_free-style_dist_es2015_index_js.1706410.js","mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW,EAAE;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gBAAgB;AACtD,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,IAAI,GAAG,MAAM;AAC/B;AACA,cAAc,IAAI,GAAG,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D,KAAK;AACL,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ,EAAE,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0BAA0B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mCAAmC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4BAA4B;AAC7C;AACA;AACA,oBAAoB,0BAA0B;AAC9C,oBAAoB,IAAI,IAAI,MAAM;AAClC;AACA,yCAAyC,IAAI,IAAI,IAAI;AACrD;AACA;AACA,iBAAiB,iCAAiC;AAClD,qDAAqD,IAAI,IAAI,SAAS,IAAI,MAAM;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB,EAAE,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW,EAAE,WAAW,EAAE,kBAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC,QAAQ,MAAqC;AAC7C;AACA,cAAc,oBAAoB,GAAG,IAAI;AACzC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAqC,GAAG,CAAE,cAAc;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ,EAAE,MAAqC,GAAG,CAAE,cAAc;AAC9F,kDAAkD,IAAI,IAAI,OAAO;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,6BAA6B,0BAA0B;AACvD;AACA","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/free-style/dist.es2015/index.js"],"sourcesContent":["/**\n * The unique id is used for unique hashes.\n */\nlet uniqueId = 0;\n/**\n * Quick dictionary lookup for unit-less numbers.\n */\nconst CSS_NUMBER = Object.create(null);\n/**\n * CSS properties that are valid unit-less numbers.\n *\n * Ref: https://github.com/facebook/react/blob/master/packages/react-dom/src/shared/CSSProperty.js\n */\nconst CSS_NUMBER_KEYS = [\n    \"animation-iteration-count\",\n    \"border-image-outset\",\n    \"border-image-slice\",\n    \"border-image-width\",\n    \"box-flex\",\n    \"box-flex-group\",\n    \"box-ordinal-group\",\n    \"column-count\",\n    \"columns\",\n    \"counter-increment\",\n    \"counter-reset\",\n    \"flex\",\n    \"flex-grow\",\n    \"flex-positive\",\n    \"flex-shrink\",\n    \"flex-negative\",\n    \"flex-order\",\n    \"font-weight\",\n    \"grid-area\",\n    \"grid-column\",\n    \"grid-column-end\",\n    \"grid-column-span\",\n    \"grid-column-start\",\n    \"grid-row\",\n    \"grid-row-end\",\n    \"grid-row-span\",\n    \"grid-row-start\",\n    \"line-clamp\",\n    \"line-height\",\n    \"opacity\",\n    \"order\",\n    \"orphans\",\n    \"tab-size\",\n    \"widows\",\n    \"z-index\",\n    \"zoom\",\n    // SVG properties.\n    \"fill-opacity\",\n    \"flood-opacity\",\n    \"stop-opacity\",\n    \"stroke-dasharray\",\n    \"stroke-dashoffset\",\n    \"stroke-miterlimit\",\n    \"stroke-opacity\",\n    \"stroke-width\"\n];\n// Add vendor prefixes to all unit-less properties.\nfor (const property of CSS_NUMBER_KEYS) {\n    for (const prefix of [\"-webkit-\", \"-ms-\", \"-moz-\", \"-o-\", \"\"]) {\n        CSS_NUMBER[prefix + property] = true;\n    }\n}\n/**\n * Escape a CSS class name.\n */\nfunction escape(str) {\n    return str.replace(/[ !#$%&()*+,./;<=>?@[\\]^`{|}~\"'\\\\]/g, \"\\\\$&\");\n}\n/**\n * Transform a JavaScript property into a CSS property.\n */\nfunction hyphenate(propertyName) {\n    return propertyName\n        .replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`)\n        .replace(/^ms-/, \"-ms-\"); // Internet Explorer vendor prefix.\n}\n/**\n * Generate a hash value from a string.\n */\nfunction stringHash(str) {\n    let value = 5381;\n    let len = str.length;\n    while (len--)\n        value = (value * 33) ^ str.charCodeAt(len);\n    return (value >>> 0).toString(36);\n}\n/**\n * Transform a style string to a CSS string.\n */\nfunction styleToString(key, value) {\n    if (value && typeof value === \"number\" && !CSS_NUMBER[key]) {\n        return `${key}:${value}px`;\n    }\n    return `${key}:${value}`;\n}\n/**\n * Sort an array of tuples by first value.\n */\nfunction sortTuples(value) {\n    return value.sort((a, b) => (a[0] > b[0] ? 1 : -1));\n}\n/**\n * Categorize user styles.\n */\nfunction parseStyles(styles, hasNestedStyles) {\n    const properties = [];\n    const nestedStyles = [];\n    // Sort keys before adding to styles.\n    for (const key of Object.keys(styles)) {\n        const name = key.trim();\n        const value = styles[key];\n        if (name.charCodeAt(0) !== 36 /* $ */ && value != null) {\n            if (typeof value === \"object\" && !Array.isArray(value)) {\n                nestedStyles.push([name, value]);\n            }\n            else {\n                properties.push([hyphenate(name), value]);\n            }\n        }\n    }\n    return {\n        style: stringifyProperties(sortTuples(properties)),\n        nested: hasNestedStyles ? nestedStyles : sortTuples(nestedStyles),\n        isUnique: !!styles.$unique\n    };\n}\n/**\n * Stringify an array of property tuples.\n */\nfunction stringifyProperties(properties) {\n    return properties\n        .map(([name, value]) => {\n        if (!Array.isArray(value))\n            return styleToString(name, value);\n        return value.map(x => styleToString(name, x)).join(\";\");\n    })\n        .join(\";\");\n}\n/**\n * Interpolate CSS selectors.\n */\nfunction interpolate(selector, parent) {\n    if (selector.indexOf(\"&\") === -1)\n        return `${parent} ${selector}`;\n    return selector.replace(/&/g, parent);\n}\n/**\n * Recursive loop building styles with deferred selectors.\n */\nfunction stylize(selector, styles, rulesList, stylesList, parent) {\n    const { style, nested, isUnique } = parseStyles(styles, selector !== \"\");\n    let pid = style;\n    if (selector.charCodeAt(0) === 64 /* @ */) {\n        const child = {\n            selector,\n            styles: [],\n            rules: [],\n            style: parent ? \"\" : style\n        };\n        rulesList.push(child);\n        // Nested styles support (e.g. `.foo > @media > .bar`).\n        if (style && parent) {\n            child.styles.push({ selector: parent, style, isUnique });\n        }\n        for (const [name, value] of nested) {\n            pid += name + stylize(name, value, child.rules, child.styles, parent);\n        }\n    }\n    else {\n        const key = parent ? interpolate(selector, parent) : selector;\n        if (style)\n            stylesList.push({ selector: key, style, isUnique });\n        for (const [name, value] of nested) {\n            pid += name + stylize(name, value, rulesList, stylesList, key);\n        }\n    }\n    return pid;\n}\n/**\n * Transform `stylize` tree into style objects.\n */\nfunction composeStylize(cache, pid, rulesList, stylesList, className, isStyle) {\n    for (const { selector, style, isUnique } of stylesList) {\n        const key = isStyle ? interpolate(selector, className) : selector;\n        const id = isUnique\n            ? `u\\0${(++uniqueId).toString(36)}`\n            : `s\\0${pid}\\0${style}`;\n        const item = new Style(style, id);\n        item.add(new Selector(key, `k\\0${pid}\\0${key}`));\n        cache.add(item);\n    }\n    for (const { selector, style, rules, styles } of rulesList) {\n        const item = new Rule(selector, style, `r\\0${pid}\\0${selector}\\0${style}`);\n        composeStylize(item, pid, rules, styles, className, isStyle);\n        cache.add(item);\n    }\n}\n/**\n * Cache to list to styles.\n */\nfunction join(arr) {\n    let res = \"\";\n    for (let i = 0; i < arr.length; i++)\n        res += arr[i];\n    return res;\n}\n/**\n * Noop changes.\n */\nconst noopChanges = {\n    add: () => undefined,\n    change: () => undefined,\n    remove: () => undefined\n};\n/**\n * Implement a cache/event emitter.\n */\nexport class Cache {\n    constructor(changes = noopChanges) {\n        this.changes = changes;\n        this.sheet = [];\n        this.changeId = 0;\n        this._keys = [];\n        this._children = Object.create(null);\n        this._counters = Object.create(null);\n    }\n    add(style) {\n        const count = this._counters[style.id] || 0;\n        const item = this._children[style.id] || style.clone();\n        this._counters[style.id] = count + 1;\n        if (count === 0) {\n            this._children[item.id] = item;\n            this._keys.push(item.id);\n            this.sheet.push(item.getStyles());\n            this.changeId++;\n            this.changes.add(item, this._keys.length - 1);\n        }\n        else if (item instanceof Cache && style instanceof Cache) {\n            const curIndex = this._keys.indexOf(style.id);\n            const prevItemChangeId = item.changeId;\n            item.merge(style);\n            if (item.changeId !== prevItemChangeId) {\n                this.sheet.splice(curIndex, 1, item.getStyles());\n                this.changeId++;\n                this.changes.change(item, curIndex, curIndex);\n            }\n        }\n    }\n    remove(style) {\n        const count = this._counters[style.id];\n        if (count) {\n            this._counters[style.id] = count - 1;\n            const item = this._children[style.id];\n            const index = this._keys.indexOf(item.id);\n            if (count === 1) {\n                delete this._counters[style.id];\n                delete this._children[style.id];\n                this._keys.splice(index, 1);\n                this.sheet.splice(index, 1);\n                this.changeId++;\n                this.changes.remove(item, index);\n            }\n            else if (item instanceof Cache && style instanceof Cache) {\n                const prevChangeId = item.changeId;\n                item.unmerge(style);\n                if (item.changeId !== prevChangeId) {\n                    this.sheet.splice(index, 1, item.getStyles());\n                    this.changeId++;\n                    this.changes.change(item, index, index);\n                }\n            }\n        }\n    }\n    values() {\n        return this._keys.map(key => this._children[key]);\n    }\n    merge(cache) {\n        for (const item of cache.values())\n            this.add(item);\n        return this;\n    }\n    unmerge(cache) {\n        for (const item of cache.values())\n            this.remove(item);\n        return this;\n    }\n    clone() {\n        return new Cache().merge(this);\n    }\n}\n/**\n * Selector is a dumb class made to represent nested CSS selectors.\n */\nexport class Selector {\n    constructor(selector, id) {\n        this.selector = selector;\n        this.id = id;\n    }\n    getStyles() {\n        return this.selector;\n    }\n    clone() {\n        return this;\n    }\n}\n/**\n * The style container registers a style string with selectors.\n */\nexport class Style extends Cache {\n    constructor(style, id) {\n        super();\n        this.style = style;\n        this.id = id;\n    }\n    getStyles() {\n        return `${this.sheet.join(\",\")}{${this.style}}`;\n    }\n    clone() {\n        return new Style(this.style, this.id).merge(this);\n    }\n}\n/**\n * Implement rule logic for style output.\n */\nexport class Rule extends Cache {\n    constructor(rule, style, id) {\n        super();\n        this.rule = rule;\n        this.style = style;\n        this.id = id;\n    }\n    getStyles() {\n        return `${this.rule}{${this.style}${join(this.sheet)}}`;\n    }\n    clone() {\n        return new Rule(this.rule, this.style, this.id).merge(this);\n    }\n}\nfunction key(pid, styles) {\n    const key = `f${stringHash(pid)}`;\n    if (process.env.NODE_ENV === \"production\" || !styles.$displayName)\n        return key;\n    return `${styles.$displayName}_${key}`;\n}\n/**\n * The FreeStyle class implements the API for everything else.\n */\nexport class FreeStyle extends Cache {\n    constructor(id, changes) {\n        super(changes);\n        this.id = id;\n    }\n    registerStyle(styles) {\n        const rulesList = [];\n        const stylesList = [];\n        const pid = stylize(\"&\", styles, rulesList, stylesList);\n        const id = key(pid, styles);\n        const selector = `.${process.env.NODE_ENV === \"production\" ? id : escape(id)}`;\n        composeStylize(this, pid, rulesList, stylesList, selector, true);\n        return id;\n    }\n    registerKeyframes(keyframes) {\n        return this.registerHashRule(\"@keyframes\", keyframes);\n    }\n    registerHashRule(prefix, styles) {\n        const rulesList = [];\n        const stylesList = [];\n        const pid = stylize(\"\", styles, rulesList, stylesList);\n        const id = key(pid, styles);\n        const selector = `${prefix} ${process.env.NODE_ENV === \"production\" ? id : escape(id)}`;\n        const rule = new Rule(selector, \"\", `h\\0${pid}\\0${prefix}`);\n        composeStylize(rule, pid, rulesList, stylesList, \"\", false);\n        this.add(rule);\n        return id;\n    }\n    registerRule(rule, styles) {\n        const rulesList = [];\n        const stylesList = [];\n        const pid = stylize(rule, styles, rulesList, stylesList);\n        composeStylize(this, pid, rulesList, stylesList, \"\", false);\n    }\n    registerCss(styles) {\n        return this.registerRule(\"\", styles);\n    }\n    getStyles() {\n        return join(this.sheet);\n    }\n    clone() {\n        return new FreeStyle(this.id, this.changes).merge(this);\n    }\n}\n/**\n * Exports a simple function to create a new instance.\n */\nexport function create(changes) {\n    return new FreeStyle(`f${(++uniqueId).toString(36)}`, changes);\n}\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":""}