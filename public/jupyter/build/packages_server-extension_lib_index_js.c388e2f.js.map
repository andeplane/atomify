{"version":3,"file":"packages_server-extension_lib_index_js.c388e2f.js","mappings":";;;;;;;;;;;;;;;;;;AAA2D;AACX;AACV;AACc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8DAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAe;AACrC,yBAAyB,mEAAgB;AACzC,wBAAwB,kEAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,KAAK;AAC9B;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc;AACvD;AACA;AACA,6BAA6B,QAAQ,EAAE,KAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,cAAc;AACxD;AACA;AACA,6BAA6B,QAAQ,EAAE,KAAK;AAC5C;AACA;AACA;AACA,8BAA8B,8CAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iDAAY,SAAS,sDAAiB;AACvE;AACA,oBAAoB,mDAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,cAAc,EAAE,IAAI;AAC9D;AACA;AACA,6BAA6B,QAAQ,EAAE,KAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mEAAgB;AACnC,uCAAuC,eAAe;AACtD;AACA,iCAAiC,MAAM,EAAE,KAAK,KAAK,eAAe;AAClE,wBAAwB,kEAAe;AACvC;AACA,sBAAsB,MAAM,QAAQ,IAAI;AACxC;AACA,0BAA0B,MAAM,EAAE,KAAK;AACvC,0CAA0C,eAAe;AACzD;AACA,yDAAyD,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,KAAK,GAAG,UAAU;AACjD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAgB;AACtC;AACA;AACA;AACA;AACA,0BAA0B,8CAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,eAAe;AAC3D;AACA,yDAAyD,KAAK;AAC9D;AACA;AACA,qBAAqB,mEAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8DAAW,4BAA4B,8DAAW;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,oBAAoB,kEAAe;AACnC;AACA;AACA,4CAA4C,yBAAyB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mDAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mDAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,KAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,eAAe;AAC3D;AACA,yDAAyD,KAAK;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,MAAM;AACjD;AACA;AACA;AACA;AACA,qBAAqB,mEAAgB;AACrC,8DAA8D,8DAAW;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oDAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,gCAAgC,8DAAW,CAAC,wEAAqB;AACjE;AACA;AACA;AACA;AACA;AACA,4BAA4B,kEAAe;AAC3C;AACA,oBAAoB,mDAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,8CAAS;AAC7D;AACA;AACA,yBAAyB,mDAAc;AACvC;AACA;AACA;AACA;AACA,8CAA8C,oDAAe;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,sDAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8DAAW,CAAC,wEAAqB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,IAAI;AACvD,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;;;;;;;;;;;;;;;;;;;;;;AC7pBwB;AAC3B;AACkB;AAC1C;AACA;AACA;AACO,sBAAsB,oDAAK;AAClC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,oBAAoB;AACrB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,6BAA6B,uEAAoB,oBAAoB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1DrB;AACA;AAC4D;AACsB;AACC;AACvB;AAC+C;AAChD;AACC;AACS;AACQ;AACvC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kEAAY;AAC1B;AACA,iBAAiB,WAAW;AAC5B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAY;AAC3B;AACA,uBAAuB,uEAAoB;AAC3C;AACA,kBAAkB,6EAAmB;AACrC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAY;AAC3B;AACA,cAAc,4DAAS;AACvB;AACA,4BAA4B,uEAAoB;AAChD,0CAA0C,uEAAoB;AAC9D,gBAAgB,cAAc;AAC9B,6BAA6B,4DAAQ;AACrC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAS;AACxB;AACA,8BAA8B,KAAK;AACnC;AACA;AACA;AACA,SAAS;AACT,+BAA+B,KAAK,cAAc,eAAe;AACjE;AACA;AACA,uDAAuD,aAAa;AACpE,SAAS;AACT,+BAA+B,KAAK;AACpC;AACA;AACA,uDAAuD,aAAa;AACpE,SAAS;AACT,iCAAiC,KAAK,cAAc,eAAe;AACnE;AACA;AACA,uDAAuD,aAAa;AACpE,SAAS;AACT,8BAA8B,MAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA;AACA,SAAS;AACT,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA,wDAAwD,aAAa;AACrE,SAAS;AACT,gCAAgC,MAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,8BAA8B,MAAM;AACpC;AACA;AACA;AACA;AACA,SAAS;AACT,iCAAiC,MAAM;AACvC;AACA;AACA,wCAAwC,aAAa;AACrD,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kFAAiC;AAC/C;AACA,mBAAmB,iFAAgC;AACnD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,eAAe;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,4DAAQ;AACtD;AACA;AACA,8CAA8C,6DAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,4DAAQ,GAAG,6DAAS;AACnF,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kEAAe;AAC7C,uCAAuC,4DAAQ;AAC/C,6BAA6B,kEAAe;AAC5C,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,4DAAQ,GAAG,6DAAS;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,6DAA6D,eAAe;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yDAAQ;AACtB,eAAe,6DAAY;AAC3B;AACA,mBAAmB,wDAAO,GAAG,aAAa;AAC1C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAQ;AACvB;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA,SAAS;AACT,gCAAgC,WAAW;AAC3C;AACA;AACA,uDAAuD,aAAa;AACpE,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6DAAY;AAC1B;AACA,mBAAmB,4DAAW;AAC9B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAY;AAC3B;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4DAAS;AACvB;AACA,mBAAmB,2DAAQ;AAC3B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAS;AACxB;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2DAAS;AACvB,eAAe,yDAAQ;AACvB;AACA,mBAAmB,0DAAQ,GAAG,SAAS;AACvC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAS;AACxB;AACA,8BAA8B,SAAS;AACvC;AACA;AACA,2DAA2D,aAAa;AACxE,SAAS;AACT;AACA;AACA;AACA,wDAAwD,aAAa;AACrE,SAAS;AACT,gCAAgC,SAAS;AACzC;AACA;AACA;AACA,2DAA2D,aAAa;AACxE,SAAS;AACT,iCAAiC,SAAS;AAC1C;AACA;AACA,wCAAwC,aAAa;AACrD,SAAS;AACT;AACA;AACA;AACA;AACA,2DAA2D,aAAa;AACxE,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAY;AAC3B,cAAc,4DAAS;AACvB;AACA,4BAA4B,uEAAoB;AAChD,0CAA0C,uEAAoB;AAC9D,gBAAgB,cAAc;AAC9B,6BAA6B,2DAAQ,GAAG,0CAA0C;AAClF;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA,wCAAwC,aAAa;AACrD,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kEAAY;AAC1B;AACA,gCAAgC,iEAAW;AAC3C;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAY;AAC3B;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/contents.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/contents/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/server-extension/lib/index.js"],"sourcesContent":["import { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { PathExt } from '@jupyterlab/coreutils';\nimport { MIME, FILE } from './tokens';\nimport { PromiseDelegate } from '@lumino/coreutils';\n/**\n * The name of the local storage.\n */\nconst DEFAULT_STORAGE_NAME = 'JupyterLite Storage';\n/**\n * The number of checkpoints to save.\n */\nconst N_CHECKPOINTS = 5;\n/**\n * A class to handle requests to /api/contents\n */\nexport class Contents {\n    /**\n     * Construct a new localForage-powered contents provider\n     */\n    constructor(options) {\n        /**\n         * A reducer for turning arbitrary binary into a string\n         */\n        this.reduceBytesToString = (data, byte) => {\n            return data + String.fromCharCode(byte);\n        };\n        this._serverContents = new Map();\n        this._storageName = DEFAULT_STORAGE_NAME;\n        this._storageDrivers = null;\n        this._localforage = options.localforage;\n        this._storageName = options.storageName || DEFAULT_STORAGE_NAME;\n        this._storageDrivers = options.storageDrivers || null;\n        this._ready = new PromiseDelegate();\n    }\n    /**\n     * Finish any initialization after server has started and all extensions are applied.\n     */\n    async initialize() {\n        await this.initStorage();\n        this._ready.resolve(void 0);\n    }\n    /**\n     * Initialize all storage instances\n     */\n    async initStorage() {\n        this._storage = this.createDefaultStorage();\n        this._counters = this.createDefaultCounters();\n        this._checkpoints = this.createDefaultCheckpoints();\n    }\n    /**\n     * A promise that resolves once all storage is fully initialized.\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * A lazy reference to the underlying storage.\n     */\n    get storage() {\n        return this.ready.then(() => this._storage);\n    }\n    /**\n     * A lazy reference to the underlying counters.\n     */\n    get counters() {\n        return this.ready.then(() => this._counters);\n    }\n    /**\n     * A lazy reference to the underlying checkpoints.\n     */\n    get checkpoints() {\n        return this.ready.then(() => this._checkpoints);\n    }\n    /**\n     * Get default options for localForage instances\n     */\n    get defaultStorageOptions() {\n        const driver = this._storageDrivers && this._storageDrivers.length ? this._storageDrivers : null;\n        return {\n            version: 1,\n            name: this._storageName,\n            ...(driver ? { driver } : {}),\n        };\n    }\n    /**\n     * Initialize the default storage for contents.\n     */\n    createDefaultStorage() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for Notebooks and Files',\n            storeName: 'files',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Initialize the default storage for counting file suffixes.\n     */\n    createDefaultCounters() {\n        return this._localforage.createInstance({\n            description: 'Store the current file suffix counters',\n            storeName: 'counters',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Create the default checkpoint storage.\n     */\n    createDefaultCheckpoints() {\n        return this._localforage.createInstance({\n            description: 'Offline Storage for Checkpoints',\n            storeName: 'checkpoints',\n            ...this.defaultStorageOptions,\n        });\n    }\n    /**\n     * Create a new untitled file or directory in the specified directory path.\n     *\n     * @param options: The options used to create the file.\n     *\n     * @returns A promise which resolves with the created file content when the file is created.\n     */\n    async newUntitled(options) {\n        var _a, _b, _c;\n        const path = (_a = options === null || options === void 0 ? void 0 : options.path) !== null && _a !== void 0 ? _a : '';\n        const type = (_b = options === null || options === void 0 ? void 0 : options.type) !== null && _b !== void 0 ? _b : 'notebook';\n        const created = new Date().toISOString();\n        let dirname = PathExt.dirname(path);\n        const basename = PathExt.basename(path);\n        const extname = PathExt.extname(path);\n        const item = await this.get(dirname);\n        // handle the case of \"Save As\", where the path points to the new file\n        // to create, e.g. subfolder/example-copy.ipynb\n        let name = '';\n        if (path && !extname && item) {\n            // directory\n            dirname = `${path}/`;\n            name = '';\n        }\n        else if (dirname && basename) {\n            // file in a subfolder\n            dirname = `${dirname}/`;\n            name = basename;\n        }\n        else {\n            // file at the top level\n            dirname = '';\n            name = path;\n        }\n        let file;\n        switch (type) {\n            case 'directory': {\n                const counter = await this._incrementCounter('directory');\n                name = `Untitled Folder${counter || ''}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: '',\n                    content: null,\n                    size: 0,\n                    writable: true,\n                    type: 'directory',\n                };\n                break;\n            }\n            case 'notebook': {\n                const counter = await this._incrementCounter('notebook');\n                name = name || `Untitled${counter || ''}.ipynb`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format: 'json',\n                    mimetype: MIME.JSON,\n                    content: Private.EMPTY_NB,\n                    size: JSON.stringify(Private.EMPTY_NB).length,\n                    writable: true,\n                    type: 'notebook',\n                };\n                break;\n            }\n            default: {\n                const ext = (_c = options === null || options === void 0 ? void 0 : options.ext) !== null && _c !== void 0 ? _c : '.txt';\n                const counter = await this._incrementCounter('file');\n                const mimetype = FILE.getType(ext) || MIME.OCTET_STREAM;\n                let format;\n                if (FILE.hasFormat(ext, 'text') || mimetype.indexOf('text') !== -1) {\n                    format = 'text';\n                }\n                else if (ext.indexOf('json') !== -1 || ext.indexOf('ipynb') !== -1) {\n                    format = 'json';\n                }\n                else {\n                    format = 'base64';\n                }\n                name = name || `untitled${counter || ''}${ext}`;\n                file = {\n                    name,\n                    path: `${dirname}${name}`,\n                    last_modified: created,\n                    created,\n                    format,\n                    mimetype,\n                    content: '',\n                    size: 0,\n                    writable: true,\n                    type: 'file',\n                };\n                break;\n            }\n        }\n        const key = file.path;\n        await (await this.storage).setItem(key, file);\n        return file;\n    }\n    /**\n     * Copy a file into a given directory.\n     *\n     * @param path - The original file path.\n     * @param toDir - The destination directory path.\n     *\n     * @returns A promise which resolves with the new contents model when the\n     *  file is copied.\n     *\n     * #### Notes\n     * The server will select the name of the copied file.\n     */\n    async copy(path, toDir) {\n        let name = PathExt.basename(path);\n        toDir = toDir === '' ? '' : `${toDir.slice(1)}/`;\n        // TODO: better handle naming collisions with existing files\n        while (await this.get(`${toDir}${name}`, { content: true })) {\n            const ext = PathExt.extname(name);\n            const base = name.replace(ext, '');\n            name = `${base} (copy)${ext}`;\n        }\n        const toPath = `${toDir}${name}`;\n        let item = await this.get(path, { content: true });\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        item = {\n            ...item,\n            name,\n            path: toPath,\n        };\n        await (await this.storage).setItem(toPath, item);\n        return item;\n    }\n    /**\n     * Get a file or directory.\n     *\n     * @param path: The path to the file.\n     * @param options: The options used to fetch the file.\n     *\n     * @returns A promise which resolves with the file content.\n     */\n    async get(path, options) {\n        // remove leading slash\n        path = decodeURIComponent(path.replace(/^\\//, ''));\n        if (path === '') {\n            return await this._getFolder(path);\n        }\n        const storage = await this.storage;\n        const item = await storage.getItem(path);\n        const serverItem = await this._getServerContents(path, options);\n        const model = (item || serverItem);\n        if (!model) {\n            return null;\n        }\n        if (!(options === null || options === void 0 ? void 0 : options.content)) {\n            return {\n                ...model,\n                content: null,\n                size: 0,\n            };\n        }\n        // for directories, find all files with the path as the prefix\n        if (model.type === 'directory') {\n            const contentMap = new Map();\n            await storage.iterate((file, key) => {\n                // use an additional slash to not include the directory itself\n                if (key === `${path}/${file.name}`) {\n                    contentMap.set(file.name, file);\n                }\n            });\n            const serverContents = serverItem\n                ? serverItem.content\n                : Array.from((await this._getServerDirectory(path)).values());\n            for (const file of serverContents) {\n                if (!contentMap.has(file.name)) {\n                    contentMap.set(file.name, file);\n                }\n            }\n            const content = [...contentMap.values()];\n            return {\n                name: PathExt.basename(path),\n                path,\n                last_modified: model.last_modified,\n                created: model.created,\n                format: 'json',\n                mimetype: MIME.JSON,\n                content,\n                size: 0,\n                writable: true,\n                type: 'directory',\n            };\n        }\n        return model;\n    }\n    /**\n     * Rename a file or directory.\n     *\n     * @param oldLocalPath - The original file path.\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with the new file content model when the file is renamed.\n     */\n    async rename(oldLocalPath, newLocalPath) {\n        const path = decodeURIComponent(oldLocalPath);\n        const file = await this.get(path, { content: true });\n        if (!file) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const modified = new Date().toISOString();\n        const name = PathExt.basename(newLocalPath);\n        const newFile = {\n            ...file,\n            name,\n            path: newLocalPath,\n            last_modified: modified,\n        };\n        const storage = await this.storage;\n        await storage.setItem(newLocalPath, newFile);\n        // remove the old file\n        await storage.removeItem(path);\n        // remove the corresponding checkpoint\n        await (await this.checkpoints).removeItem(path);\n        // if a directory, recurse through all children\n        if (file.type === 'directory') {\n            let child;\n            for (child of file.content) {\n                await this.rename(URLExt.join(oldLocalPath, child.name), URLExt.join(newLocalPath, child.name));\n            }\n        }\n        return newFile;\n    }\n    /**\n     * Save a file.\n     *\n     * @param path - The desired file path.\n     * @param options - Optional overrides to the model.\n     *\n     * @returns A promise which resolves with the file content model when the file is saved.\n     */\n    async save(path, options = {}) {\n        var _a;\n        path = decodeURIComponent(path);\n        // process the file if coming from an upload\n        const ext = PathExt.extname((_a = options.name) !== null && _a !== void 0 ? _a : '');\n        let item = await this.get(path);\n        if (!item) {\n            item = await this.newUntitled({ path, ext, type: 'file' });\n        }\n        if (!item) {\n            return null;\n        }\n        // override with the new values\n        const modified = new Date().toISOString();\n        item = {\n            ...item,\n            ...options,\n            last_modified: modified,\n        };\n        if (options.content && options.format === 'base64') {\n            if (ext === '.ipynb') {\n                item = {\n                    ...item,\n                    content: JSON.parse(this.unescapeContent(options.content)),\n                    format: 'json',\n                    type: 'notebook',\n                };\n            }\n            else if (FILE.hasFormat(ext, 'json')) {\n                item = {\n                    ...item,\n                    content: JSON.parse(this.unescapeContent(options.content)),\n                    format: 'json',\n                    type: 'file',\n                };\n            }\n            else if (FILE.hasFormat(ext, 'text')) {\n                item = {\n                    ...item,\n                    content: this.unescapeContent(options.content),\n                    format: 'text',\n                    type: 'file',\n                };\n            }\n        }\n        await (await this.storage).setItem(path, item);\n        return item;\n    }\n    unescapeContent(content) {\n        return decodeURIComponent(escape(atob(content)));\n    }\n    /**\n     * Delete a file from browser storage.\n     *\n     * Has no effect on server-backed files, which will re-appear with their\n     * original timestamp.\n     *\n     * @param path - The path to the file.\n     */\n    async delete(path) {\n        path = decodeURIComponent(path);\n        const slashed = `${path}/`;\n        const toDelete = (await (await this.storage).keys()).filter((key) => key === path || key.startsWith(slashed));\n        await Promise.all(toDelete.map(this.forgetPath, this));\n    }\n    /**\n     * Remove the localForage and checkpoints for a path.\n     *\n     * @param path - The path to the file\n     */\n    async forgetPath(path) {\n        await Promise.all([\n            (await this.storage).removeItem(path),\n            (await this.checkpoints).removeItem(path),\n        ]);\n    }\n    /**\n     * Create a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with the new checkpoint model when the\n     *   checkpoint is created.\n     */\n    async createCheckpoint(path) {\n        var _a;\n        const checkpoints = await this.checkpoints;\n        path = decodeURIComponent(path);\n        const item = await this.get(path, { content: true });\n        if (!item) {\n            throw Error(`Could not find file with path ${path}`);\n        }\n        const copies = ((_a = (await checkpoints.getItem(path))) !== null && _a !== void 0 ? _a : []).filter(Boolean);\n        copies.push(item);\n        // keep only a certain amount of checkpoints per file\n        if (copies.length > N_CHECKPOINTS) {\n            copies.splice(0, copies.length - N_CHECKPOINTS);\n        }\n        await checkpoints.setItem(path, copies);\n        const id = `${copies.length - 1}`;\n        return { id, last_modified: item.last_modified };\n    }\n    /**\n     * List available checkpoints for a file.\n     *\n     * @param path - The path of the file.\n     *\n     * @returns A promise which resolves with a list of checkpoint models for\n     *    the file.\n     */\n    async listCheckpoints(path) {\n        const copies = (await (await this.checkpoints).getItem(path)) || [];\n        return copies.filter(Boolean).map(this.normalizeCheckpoint, this);\n    }\n    normalizeCheckpoint(model, id) {\n        return { id: id.toString(), last_modified: model.last_modified };\n    }\n    /**\n     * Restore a file to a known checkpoint state.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to restore.\n     *\n     * @returns A promise which resolves when the checkpoint is restored.\n     */\n    async restoreCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await (await this.checkpoints).getItem(path)) || []);\n        const id = parseInt(checkpointID);\n        const item = copies[id];\n        await (await this.storage).setItem(path, item);\n    }\n    /**\n     * Delete a checkpoint for a file.\n     *\n     * @param path - The path of the file.\n     * @param checkpointID - The id of the checkpoint to delete.\n     *\n     * @returns A promise which resolves when the checkpoint is deleted.\n     */\n    async deleteCheckpoint(path, checkpointID) {\n        path = decodeURIComponent(path);\n        const copies = ((await (await this.checkpoints).getItem(path)) || []);\n        const id = parseInt(checkpointID);\n        copies.splice(id, 1);\n        await (await this.checkpoints).setItem(path, copies);\n    }\n    /**\n     * retrieve the contents for this path from the union of local storage and\n     * `api/contents/{path}/all.json`.\n     *\n     * @param path - The contents path to retrieve\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getFolder(path) {\n        const content = new Map();\n        const storage = await this.storage;\n        await storage.iterate((file, key) => {\n            if (key.includes('/')) {\n                return;\n            }\n            content.set(file.path, file);\n        });\n        // layer in contents that don't have local overwrites\n        for (const file of (await this._getServerDirectory(path)).values()) {\n            if (!content.has(file.path)) {\n                content.set(file.path, file);\n            }\n        }\n        if (path && content.size === 0) {\n            return null;\n        }\n        return {\n            name: '',\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'json',\n            mimetype: MIME.JSON,\n            content: Array.from(content.values()),\n            size: 0,\n            writable: true,\n            type: 'directory',\n        };\n    }\n    /**\n     * Attempt to recover the model from `{:path}/__all__.json` file, fall back to\n     * deriving the model (including content) off the file in `/files/`. Otherwise\n     * return `null`.\n     */\n    async _getServerContents(path, options) {\n        const name = PathExt.basename(path);\n        const parentContents = await this._getServerDirectory(URLExt.join(path, '..'));\n        let model = parentContents.get(name);\n        if (!model) {\n            return null;\n        }\n        model = model || {\n            name,\n            path,\n            last_modified: new Date(0).toISOString(),\n            created: new Date(0).toISOString(),\n            format: 'text',\n            mimetype: MIME.PLAIN_TEXT,\n            type: 'file',\n            writable: true,\n            content: null,\n        };\n        if (options === null || options === void 0 ? void 0 : options.content) {\n            if (model.type === 'directory') {\n                const serverContents = await this._getServerDirectory(path);\n                model = { ...model, content: Array.from(serverContents.values()) };\n            }\n            else {\n                const fileUrl = URLExt.join(PageConfig.getBaseUrl(), 'files', path);\n                const response = await fetch(fileUrl);\n                if (!response.ok) {\n                    return null;\n                }\n                const mimetype = model.mimetype || response.headers.get('Content-Type');\n                const ext = PathExt.extname(name);\n                if (model.type === 'notebook' ||\n                    FILE.hasFormat(ext, 'json') ||\n                    (mimetype === null || mimetype === void 0 ? void 0 : mimetype.indexOf('json')) !== -1 ||\n                    path.match(/\\.(ipynb|[^/]*json[^/]*)$/)) {\n                    model = {\n                        ...model,\n                        content: await response.json(),\n                        format: 'json',\n                        mimetype: model.mimetype || MIME.JSON,\n                    };\n                }\n                else if (FILE.hasFormat(ext, 'text') || mimetype.indexOf('text') !== -1) {\n                    model = {\n                        ...model,\n                        content: await response.text(),\n                        format: 'text',\n                        mimetype: mimetype || MIME.PLAIN_TEXT,\n                    };\n                }\n                else {\n                    model = {\n                        ...model,\n                        content: btoa(new Uint8Array(await response.arrayBuffer()).reduce(this.reduceBytesToString, '')),\n                        format: 'base64',\n                        mimetype: mimetype || MIME.OCTET_STREAM,\n                    };\n                }\n            }\n        }\n        return model;\n    }\n    /**\n     * retrieve the contents for this path from `__index__.json` in the appropriate\n     * folder.\n     *\n     * @param newLocalPath - The new file path.\n     *\n     * @returns A promise which resolves with a Map of contents, keyed by local file name\n     */\n    async _getServerDirectory(path) {\n        const content = this._serverContents.get(path) || new Map();\n        if (!this._serverContents.has(path)) {\n            const apiURL = URLExt.join(PageConfig.getBaseUrl(), 'api/contents', path, 'all.json');\n            try {\n                const response = await fetch(apiURL);\n                const json = JSON.parse(await response.text());\n                for (const file of json['content']) {\n                    content.set(file.name, file);\n                }\n            }\n            catch (err) {\n                console.warn(`don't worry, about ${err}... nothing's broken. If there had been a\n          file at ${apiURL}, you might see some more files.`);\n            }\n            this._serverContents.set(path, content);\n        }\n        return content;\n    }\n    /**\n     * Increment the counter for a given file type.\n     * Used to avoid collisions when creating new untitled files.\n     *\n     * @param type The file type to increment the counter for.\n     */\n    async _incrementCounter(type) {\n        var _a;\n        const counters = await this.counters;\n        const current = (_a = (await counters.getItem(type))) !== null && _a !== void 0 ? _a : -1;\n        const counter = current + 1;\n        await counters.setItem(type, counter);\n        return counter;\n    }\n}\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The content for an empty notebook.\n     */\n    Private.EMPTY_NB = {\n        metadata: {\n            orig_nbformat: 4,\n        },\n        nbformat_minor: 4,\n        nbformat: 4,\n        cells: [],\n    };\n})(Private || (Private = {}));\n","import { PageConfig } from '@jupyterlab/coreutils';\nimport mime from 'mime';\nimport { Token } from '@lumino/coreutils';\n/**\n * The token for the settings service.\n */\nexport const IContents = new Token('@jupyterlite/contents:IContents');\n/**\n * Commonly-used mimetypes\n */\nexport var MIME;\n(function (MIME) {\n    MIME.JSON = 'application/json';\n    MIME.PLAIN_TEXT = 'text/plain';\n    MIME.OCTET_STREAM = 'octet/stream';\n})(MIME || (MIME = {}));\n/**\n * A namespace for file constructs.\n */\nexport var FILE;\n(function (FILE) {\n    /**\n     * Build-time configured file types.\n     */\n    const TYPES = JSON.parse(PageConfig.getOption('fileTypes') || '{}');\n    /**\n     * Get a mimetype (or fallback).\n     */\n    function getType(ext, defaultType = null) {\n        ext = ext.toLowerCase();\n        for (const fileType of Object.values(TYPES)) {\n            for (const fileExt of fileType.extensions || []) {\n                if (fileExt === ext && fileType.mimeTypes && fileType.mimeTypes.length) {\n                    return fileType.mimeTypes[0];\n                }\n            }\n        }\n        return mime.getType(ext) || defaultType || MIME.OCTET_STREAM;\n    }\n    FILE.getType = getType;\n    /**\n     * Determine whether the given extension matches a given fileFormat.\n     */\n    function hasFormat(ext, fileFormat) {\n        ext = ext.toLowerCase();\n        for (const fileType of Object.values(TYPES)) {\n            if (fileType.fileFormat !== fileFormat) {\n                continue;\n            }\n            for (const fileExt of fileType.extensions || []) {\n                if (fileExt === ext) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    FILE.hasFormat = hasFormat;\n})(FILE || (FILE = {}));\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PageConfig, PathExt } from '@jupyterlab/coreutils';\nimport { Contents, DIR_MODE, FILE_MODE, IContents, } from '@jupyterlite/contents';\nimport { IKernels, Kernels, IKernelSpecs, KernelSpecs } from '@jupyterlite/kernel';\nimport { ILicenses, Licenses } from '@jupyterlite/licenses';\nimport { IServiceWorkerRegistrationWrapper, ServiceWorkerRegistrationWrapper, } from '@jupyterlite/server';\nimport { ISessions, Sessions } from '@jupyterlite/session';\nimport { ISettings, Settings } from '@jupyterlite/settings';\nimport { ITranslation, Translation } from '@jupyterlite/translation';\nimport { ILocalForage, ensureMemoryStorage } from '@jupyterlite/localforage';\nimport localforage from 'localforage';\n/**\n * The localforage plugin\n */\nconst localforagePlugin = {\n    id: '@jupyterlite/server-extension:localforage',\n    autoStart: true,\n    provides: ILocalForage,\n    activate: (app) => {\n        return { localforage };\n    },\n};\n/**\n * The volatile localforage memory plugin\n */\nconst localforageMemoryPlugin = {\n    id: '@jupyterlite/server-extension:localforage-memory-storage',\n    autoStart: true,\n    requires: [ILocalForage],\n    activate: async (app, forage) => {\n        if (JSON.parse(PageConfig.getOption('enableMemoryStorage') || 'false')) {\n            console.warn('Memory storage fallback enabled: contents and settings may not be saved');\n            await ensureMemoryStorage(forage.localforage);\n        }\n    },\n};\n/**\n * The contents service plugin.\n */\nconst contentsPlugin = {\n    id: '@jupyterlite/server-extension:contents',\n    requires: [ILocalForage],\n    autoStart: true,\n    provides: IContents,\n    activate: (app, forage) => {\n        const storageName = PageConfig.getOption('contentsStorageName');\n        const storageDrivers = JSON.parse(PageConfig.getOption('contentsStorageDrivers') || 'null');\n        const { localforage } = forage;\n        const contents = new Contents({\n            storageName,\n            storageDrivers,\n            localforage,\n        });\n        app.started.then(() => contents.initialize().catch(console.warn));\n        return contents;\n    },\n};\n/**\n * A plugin providing the routes for the contents service.\n */\nconst contentsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:contents-routes',\n    autoStart: true,\n    requires: [IContents],\n    activate: (app, contents) => {\n        // GET /api/contents/{path}/checkpoints - Get a list of checkpoints for a file\n        app.router.get('/api/contents/(.+)/checkpoints', async (req, filename) => {\n            const res = await contents.listCheckpoints(filename);\n            return new Response(JSON.stringify(res));\n        });\n        // POST /api/contents/{path}/checkpoints/{checkpoint_id} - Restore a file to a particular checkpointed state\n        app.router.post('/api/contents/(.+)/checkpoints/(.*)', async (req, filename, checkpoint) => {\n            const res = await contents.restoreCheckpoint(filename, checkpoint);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n        // POST /api/contents/{path}/checkpoints - Create a new checkpoint for a file\n        app.router.post('/api/contents/(.+)/checkpoints', async (req, filename) => {\n            const res = await contents.createCheckpoint(filename);\n            return new Response(JSON.stringify(res), { status: 201 });\n        });\n        // DELETE /api/contents/{path}/checkpoints/{checkpoint_id} - Delete a checkpoint\n        app.router.delete('/api/contents/(.+)/checkpoints/(.*)', async (req, filename, checkpoint) => {\n            const res = await contents.deleteCheckpoint(filename, checkpoint);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n        // GET /api/contents/{path} - Get contents of file or directory\n        app.router.get('/api/contents(.*)', async (req, filename) => {\n            var _a;\n            const options = {\n                content: ((_a = req.query) === null || _a === void 0 ? void 0 : _a.content) === '1',\n            };\n            const nb = await contents.get(filename, options);\n            if (!nb) {\n                return new Response(null, { status: 404 });\n            }\n            return new Response(JSON.stringify(nb));\n        });\n        // POST /api/contents/{path} - Create a new file in the specified path\n        app.router.post('/api/contents(.*)', async (req, path) => {\n            const options = req.body;\n            const copyFrom = options === null || options === void 0 ? void 0 : options.copy_from;\n            let file;\n            if (copyFrom) {\n                file = await contents.copy(copyFrom, path);\n            }\n            else {\n                file = await contents.newUntitled(options);\n            }\n            if (!file) {\n                return new Response(null, { status: 400 });\n            }\n            return new Response(JSON.stringify(file), { status: 201 });\n        });\n        // PATCH /api/contents/{path} - Rename a file or directory without re-uploading content\n        app.router.patch('/api/contents(.*)', async (req, filename) => {\n            var _a, _b;\n            const newPath = (_b = (_a = req.body) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : '';\n            filename = filename[0] === '/' ? filename.slice(1) : filename;\n            const nb = await contents.rename(filename, newPath);\n            return new Response(JSON.stringify(nb));\n        });\n        // PUT /api/contents/{path} - Save or upload a file\n        app.router.put('/api/contents/(.+)', async (req, filename) => {\n            const body = req.body;\n            const nb = await contents.save(filename, body);\n            return new Response(JSON.stringify(nb));\n        });\n        // DELETE /api/contents/{path} - Delete a file in the given path\n        app.router.delete('/api/contents/(.+)', async (req, filename) => {\n            await contents.delete(filename);\n            return new Response(null, { status: 204 });\n        });\n    },\n};\n/**\n * A plugin installing the service worker.\n */\nconst serviceWorkerPlugin = {\n    id: '@jupyterlite/server-extension:service-worker',\n    autoStart: true,\n    provides: IServiceWorkerRegistrationWrapper,\n    activate: (app) => {\n        return new ServiceWorkerRegistrationWrapper();\n    },\n};\n/**\n * A plugin handling communication with the Emscpriten file system.\n */\nconst emscriptenFileSystemPlugin = {\n    id: '@jupyterlite/server-extension:emscripten-filesystem',\n    autoStart: true,\n    activate: (app) => {\n        // Setup communication with service worker for the virtual fs\n        const broadcast = new BroadcastChannel('/api/drive.v1');\n        let subitems;\n        broadcast.onmessage = async (event) => {\n            const request = event.data;\n            const contentManager = app.serviceManager.contents;\n            const path = request.path;\n            let model;\n            switch (request.method) {\n                case 'readdir': {\n                    model = await contentManager.get(path, { content: true });\n                    if (model.type === 'directory' && model.content) {\n                        subitems = model.content.map((subcontent) => subcontent.name);\n                        broadcast.postMessage(subitems);\n                    }\n                    else {\n                        broadcast.postMessage([]);\n                    }\n                    break;\n                }\n                case 'rmdir': {\n                    await contentManager.delete(path);\n                    broadcast.postMessage(null);\n                    break;\n                }\n                case 'rename': {\n                    await contentManager.rename(path, request.data.newPath);\n                    broadcast.postMessage(null);\n                    break;\n                }\n                case 'getmode': {\n                    model = await contentManager.get(path);\n                    if (model.type === 'directory') {\n                        broadcast.postMessage(DIR_MODE);\n                    }\n                    else {\n                        broadcast.postMessage(FILE_MODE);\n                    }\n                    break;\n                }\n                case 'lookup': {\n                    try {\n                        model = await contentManager.get(path);\n                        broadcast.postMessage({\n                            ok: true,\n                            mode: model.type === 'directory' ? DIR_MODE : FILE_MODE,\n                        });\n                    }\n                    catch (e) {\n                        broadcast.postMessage({\n                            ok: false,\n                        });\n                    }\n                    break;\n                }\n                case 'mknod': {\n                    const mode = Number.parseInt(request.data.mode);\n                    model = await contentManager.newUntitled({\n                        path: PathExt.dirname(path),\n                        type: mode === DIR_MODE ? 'directory' : 'file',\n                        ext: PathExt.extname(path),\n                    });\n                    await contentManager.rename(model.path, path);\n                    broadcast.postMessage(null);\n                    break;\n                }\n                case 'getattr': {\n                    model = await contentManager.get(path);\n                    broadcast.postMessage({\n                        dev: 0,\n                        ino: 0,\n                        mode: model.type === 'directory' ? DIR_MODE : FILE_MODE,\n                        nlink: 0,\n                        uid: 0,\n                        gid: 0,\n                        rdev: 0,\n                        size: model.size || 0,\n                        blksize: 0,\n                        blocks: 0,\n                        atime: model.last_modified,\n                        mtime: model.last_modified,\n                        ctime: model.last_modified,\n                        timestamp: 0,\n                    });\n                    break;\n                }\n                case 'get': {\n                    model = await contentManager.get(path, { content: true });\n                    if (model.type === 'directory') {\n                        broadcast.postMessage(null);\n                        return;\n                    }\n                    let content = model.content;\n                    if (model.format === 'json') {\n                        content = JSON.stringify(model.content);\n                    }\n                    broadcast.postMessage({\n                        content,\n                        format: model.format,\n                    });\n                    break;\n                }\n                case 'put': {\n                    await contentManager.save(path, {\n                        content: request.data.format === 'json'\n                            ? JSON.parse(request.data.data)\n                            : request.data.data,\n                        type: 'file',\n                        format: request.data.format,\n                    });\n                    broadcast.postMessage(null);\n                    break;\n                }\n            }\n        };\n    },\n};\n/**\n * The kernels service plugin.\n */\nconst kernelsPlugin = {\n    id: '@jupyterlite/server-extension:kernels',\n    autoStart: true,\n    provides: IKernels,\n    requires: [IKernelSpecs],\n    activate: (app, kernelspecs) => {\n        return new Kernels({ kernelspecs });\n    },\n};\n/**\n * A plugin providing the routes for the kernels service\n */\nconst kernelsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:kernels-routes',\n    autoStart: true,\n    requires: [IKernels],\n    activate: (app, kernels) => {\n        // POST /api/kernels/{kernel_id} - Restart a kernel\n        app.router.post('/api/kernels/(.*)/restart', async (req, kernelId) => {\n            const res = await kernels.restart(kernelId);\n            return new Response(JSON.stringify(res));\n        });\n        // DELETE /api/kernels/{kernel_id} - Kill a kernel and delete the kernel id\n        app.router.delete('/api/kernels/(.*)', async (req, kernelId) => {\n            const res = await kernels.shutdown(kernelId);\n            return new Response(JSON.stringify(res), { status: 204 });\n        });\n    },\n};\n/**\n * The kernel spec service plugin.\n */\nconst kernelSpecPlugin = {\n    id: '@jupyterlite/server-extension:kernelspec',\n    autoStart: true,\n    provides: IKernelSpecs,\n    activate: (app) => {\n        return new KernelSpecs();\n    },\n};\n/**\n * A plugin providing the routes for the kernelspec service.\n */\nconst kernelSpecRoutesPlugin = {\n    id: '@jupyterlite/server-extension:kernelspec-routes',\n    autoStart: true,\n    requires: [IKernelSpecs],\n    activate: (app, kernelspecs) => {\n        app.router.get('/api/kernelspecs', async (req) => {\n            const { specs } = kernelspecs;\n            if (!specs) {\n                return new Response(null);\n            }\n            // follow the same format as in Jupyter Server\n            const allKernelSpecs = {};\n            const allSpecs = specs.kernelspecs;\n            Object.keys(allSpecs).forEach((name) => {\n                const spec = allSpecs[name];\n                const { resources } = spec !== null && spec !== void 0 ? spec : {};\n                allKernelSpecs[name] = {\n                    name,\n                    spec,\n                    resources,\n                };\n            });\n            const res = {\n                default: specs.default,\n                kernelspecs: allKernelSpecs,\n            };\n            return new Response(JSON.stringify(res));\n        });\n    },\n};\n/**\n * The licenses service plugin\n */\nconst licensesPlugin = {\n    id: '@jupyterlite/server-extension:licenses',\n    autoStart: true,\n    provides: ILicenses,\n    activate: (app) => {\n        return new Licenses();\n    },\n};\n/**\n * A plugin providing the routes for the licenses service.\n */\nconst licensesRoutesPlugin = {\n    id: '@jupyterlite/server-extension:licenses-routes',\n    autoStart: true,\n    requires: [ILicenses],\n    activate(app, licenses) {\n        app.router.get('/api/licenses', async (req) => {\n            const res = await licenses.get();\n            return new Response(JSON.stringify(res));\n        });\n    },\n};\n/**\n * A plugin providing the routes for the nbconvert service.\n * TODO: provide the service in a separate plugin?\n */\nconst nbconvertRoutesPlugin = {\n    id: '@jupyterlite/server-extension:nbconvert-routes',\n    autoStart: true,\n    activate: (app) => {\n        app.router.get('/api/nbconvert', async (req) => {\n            return new Response(JSON.stringify({}));\n        });\n    },\n};\n/**\n * The sessions service plugin.\n */\nconst sessionsPlugin = {\n    id: '@jupyterlite/server-extension:sessions',\n    autoStart: true,\n    provides: ISessions,\n    requires: [IKernels],\n    activate: (app, kernels) => {\n        return new Sessions({ kernels });\n    },\n};\n/**\n * A plugin providing the routes for the session service.\n */\nconst sessionsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:sessions-routes',\n    autoStart: true,\n    requires: [ISessions],\n    activate: (app, sessions) => {\n        // GET /api/sessions/{session} - Get session\n        app.router.get('/api/sessions/(.+)', async (req, id) => {\n            const session = await sessions.get(id);\n            return new Response(JSON.stringify(session), { status: 200 });\n        });\n        // GET /api/sessions - List available sessions\n        app.router.get('/api/sessions', async (req) => {\n            const list = await sessions.list();\n            return new Response(JSON.stringify(list), { status: 200 });\n        });\n        // PATCH /api/sessions/{session} - This can be used to rename a session\n        app.router.patch('/api/sessions(.*)', async (req, id) => {\n            const options = req.body;\n            const session = await sessions.patch(options);\n            return new Response(JSON.stringify(session), { status: 200 });\n        });\n        // DELETE /api/sessions/{session} - Delete a session\n        app.router.delete('/api/sessions/(.+)', async (req, id) => {\n            await sessions.shutdown(id);\n            return new Response(null, { status: 204 });\n        });\n        // POST /api/sessions - Create a new session or return an existing session if a session of the same name already exists\n        app.router.post('/api/sessions', async (req) => {\n            const options = req.body;\n            const session = await sessions.startNew(options);\n            return new Response(JSON.stringify(session), { status: 201 });\n        });\n    },\n};\n/**\n * The settings service plugin.\n */\nconst settingsPlugin = {\n    id: '@jupyterlite/server-extension:settings',\n    autoStart: true,\n    requires: [ILocalForage],\n    provides: ISettings,\n    activate: (app, forage) => {\n        const storageName = PageConfig.getOption('settingsStorageName');\n        const storageDrivers = JSON.parse(PageConfig.getOption('settingsStorageDrivers') || 'null');\n        const { localforage } = forage;\n        const settings = new Settings({ storageName, storageDrivers, localforage });\n        app.started.then(() => settings.initialize().catch(console.warn));\n        return settings;\n    },\n};\n/**\n * A plugin providing the routes for the settings service.\n */\nconst settingsRoutesPlugin = {\n    id: '@jupyterlite/server-extension:settings-routes',\n    autoStart: true,\n    requires: [ISettings],\n    activate: (app, settings) => {\n        // TODO: improve the regex\n        // const pluginPattern = new RegExp(/(?:@([^/]+?)[/])?([^/]+?):(\\w+)/);\n        const pluginPattern = '/api/settings/((?:@([^/]+?)[/])?([^/]+?):([^:]+))$';\n        app.router.get(pluginPattern, async (req, pluginId) => {\n            const setting = await settings.get(pluginId);\n            return new Response(JSON.stringify(setting));\n        });\n        app.router.put(pluginPattern, async (req, pluginId) => {\n            const body = req.body;\n            const { raw } = body;\n            await settings.save(pluginId, raw);\n            return new Response(null, { status: 204 });\n        });\n        app.router.get('/api/settings', async (req) => {\n            const plugins = await settings.getAll();\n            return new Response(JSON.stringify(plugins));\n        });\n    },\n};\n/**\n * The translation service plugin.\n */\nconst translationPlugin = {\n    id: '@jupyterlite/server-extension:translation',\n    autoStart: true,\n    provides: ITranslation,\n    activate: (app) => {\n        const translation = new Translation();\n        app.router.get('/api/translations/?(.*)', async (req, locale) => {\n            const data = await translation.get(locale || 'all');\n            return new Response(JSON.stringify(data));\n        });\n        return translation;\n    },\n};\n/**\n * A plugin providing the routes for the translation service.\n */\nconst translationRoutesPlugin = {\n    id: '@jupyterlite/server-extension:translation-routes',\n    autoStart: true,\n    requires: [ITranslation],\n    activate: (app, translation) => {\n        app.router.get('/api/translations/?(.*)', async (req, locale) => {\n            const data = await translation.get(locale || 'all');\n            return new Response(JSON.stringify(data));\n        });\n    },\n};\nconst plugins = [\n    contentsPlugin,\n    contentsRoutesPlugin,\n    emscriptenFileSystemPlugin,\n    kernelsPlugin,\n    kernelsRoutesPlugin,\n    kernelSpecPlugin,\n    kernelSpecRoutesPlugin,\n    licensesPlugin,\n    licensesRoutesPlugin,\n    localforageMemoryPlugin,\n    localforagePlugin,\n    nbconvertRoutesPlugin,\n    serviceWorkerPlugin,\n    sessionsPlugin,\n    sessionsRoutesPlugin,\n    settingsPlugin,\n    settingsRoutesPlugin,\n    translationPlugin,\n    translationRoutesPlugin,\n];\nexport default plugins;\n"],"names":[],"sourceRoot":""}