{"version":3,"file":"node_modules_jupyterlab_pdf-extension_lib_index_js.afc28f7.js","mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACoD;AACI;AACf;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACO,0BAA0B,mDAAM;AACvC;AACA;AACA;AACA;AACA,0BAA0B,8DAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kBAAkB,EAAE,wBAAwB;AACnF;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kEAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,UAAU,EAAC;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gCAAgC;AAC7D;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA,CAAC,0BAA0B;AAC3B","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/pdf-extension/lib/index.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module pdf-extension\n */\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { DisposableDelegate } from '@lumino/disposable';\nimport { Widget } from '@lumino/widgets';\n/**\n * The MIME type for PDF.\n */\nconst MIME_TYPE = 'application/pdf';\n/**\n * A class for rendering a PDF document.\n */\nexport class RenderedPDF extends Widget {\n    constructor() {\n        super();\n        this._base64 = '';\n        this._disposable = null;\n        this._ready = new PromiseDelegate();\n        this.addClass('jp-PDFContainer');\n        // We put the object in an iframe, which seems to have a better chance\n        // of retaining its scroll position upon tab focusing, moving around etc.\n        const iframe = document.createElement('iframe');\n        this.node.appendChild(iframe);\n        // The iframe content window is not available until the onload event.\n        iframe.onload = () => {\n            const body = iframe.contentWindow.document.createElement('body');\n            body.style.margin = '0px';\n            iframe.contentWindow.document.body = body;\n            this._object = iframe.contentWindow.document.createElement('object');\n            // work around for https://discussions.apple.com/thread/252247740\n            // Detect if running on Desktop Safari\n            if (!window.safari) {\n                this._object.type = MIME_TYPE;\n            }\n            this._object.width = '100%';\n            this._object.height = '100%';\n            body.appendChild(this._object);\n            this._ready.resolve(void 0);\n        };\n    }\n    /**\n     * Render PDF into this widget's node.\n     */\n    async renderModel(model) {\n        await this._ready.promise;\n        const data = model.data[MIME_TYPE];\n        if (!data ||\n            (data.length === this._base64.length && data === this._base64)) {\n            // If there is no data, or if the string has not changed, we do not\n            // need to re-parse the data and rerender. We do, however, check\n            // for a fragment if the user wants to scroll the output.\n            if (model.metadata.fragment && this._object.data) {\n                const url = this._object.data;\n                this._object.data = `${url.split('#')[0]}${model.metadata.fragment}`;\n            }\n            // For some opaque reason, Firefox seems to loose its scroll position\n            // upon unhiding a PDF. But triggering a refresh of the URL makes it\n            // find it again. No idea what the reason for this is.\n            if (Private.IS_FIREFOX) {\n                this._object.data = this._object.data; // eslint-disable-line\n            }\n            return Promise.resolve(void 0);\n        }\n        this._base64 = data;\n        const blob = Private.b64toBlob(data, MIME_TYPE);\n        // Release reference to any previous object url.\n        if (this._disposable) {\n            this._disposable.dispose();\n        }\n        let objectUrl = URL.createObjectURL(blob);\n        if (model.metadata.fragment) {\n            objectUrl += model.metadata.fragment;\n        }\n        this._object.data = objectUrl;\n        // Set the disposable release the object URL.\n        this._disposable = new DisposableDelegate(() => {\n            try {\n                URL.revokeObjectURL(objectUrl);\n            }\n            catch (error) {\n                /* no-op */\n            }\n        });\n        return;\n    }\n    /**\n     * Handle a `before-hide` message.\n     */\n    onBeforeHide() {\n        // Dispose of any URL fragment before hiding the widget\n        // so that it is not remembered upon show. Only Firefox\n        // seems to have a problem with this.\n        if (Private.IS_FIREFOX) {\n            this._object.data = this._object.data.split('#')[0];\n        }\n    }\n    /**\n     * Dispose of the resources held by the pdf widget.\n     */\n    dispose() {\n        if (this._disposable) {\n            this._disposable.dispose();\n        }\n        super.dispose();\n    }\n}\n/**\n * A mime renderer factory for PDF data.\n */\nexport const rendererFactory = {\n    safe: false,\n    mimeTypes: [MIME_TYPE],\n    defaultRank: 100,\n    createRenderer: options => new RenderedPDF()\n};\nconst extensions = [\n    {\n        id: '@jupyterlab/pdf-extension:factory',\n        rendererFactory,\n        dataType: 'string',\n        documentWidgetFactoryOptions: {\n            name: 'PDF',\n            modelName: 'base64',\n            primaryFileType: 'PDF',\n            fileTypes: ['PDF'],\n            defaultFor: ['PDF']\n        }\n    }\n];\nexport default extensions;\n/**\n * A namespace for PDF widget private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A flag for determining whether the user is using Firefox.\n     * There are some different PDF viewer behaviors on Firefox,\n     * and we try to address them with this. User agent string parsing\n     * is *not* reliable, so this should be considered a best-effort test.\n     */\n    Private.IS_FIREFOX = /Firefox/.test(navigator.userAgent);\n    /**\n     * Convert a base64 encoded string to a Blob object.\n     * Modified from a snippet found here:\n     * https://stackoverflow.com/questions/16245767/creating-a-blob-from-a-base64-string-in-javascript\n     *\n     * @param b64Data - The base64 encoded data.\n     *\n     * @param contentType - The mime type of the data.\n     *\n     * @param sliceSize - The size to chunk the data into for processing.\n     *\n     * @returns a Blob for the data.\n     */\n    function b64toBlob(b64Data, contentType = '', sliceSize = 512) {\n        const byteCharacters = atob(b64Data);\n        const byteArrays = [];\n        for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {\n            const slice = byteCharacters.slice(offset, offset + sliceSize);\n            const byteNumbers = new Array(slice.length);\n            for (let i = 0; i < slice.length; i++) {\n                byteNumbers[i] = slice.charCodeAt(i);\n            }\n            const byteArray = new Uint8Array(byteNumbers);\n            byteArrays.push(byteArray);\n        }\n        return new Blob(byteArrays, { type: contentType });\n    }\n    Private.b64toBlob = b64toBlob;\n})(Private || (Private = {}));\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":""}