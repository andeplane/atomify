{"version":3,"file":"node_modules_jupyterlab_htmlviewer_lib_index_js-_f0bb1.800670f.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6G;AACrD;AACmB;AAClB;AACD;AACd;AACC;AACZ;AAC/B;AACA;AACA;AACO,+BAA+B,oDAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yBAAyB,mEAAc;AAC9C;AACA;AACA;AACA;AACA,4CAA4C,cAAc,aAAa,wDAAM,GAAG,gCAAgC,GAAG;AACnH;AACA;AACA;AACA;AACA,mCAAmC,qDAAM;AACzC,gDAAgD,mEAAc;AAC9D;AACA;AACA;AACA;AACA,gCAAgC,kEAAe;AAC/C;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,qEAAgB;AACvD;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,mEAAc;AACjG,mBAAmB,+DAAa;AAChC,kBAAkB,kEAAW;AAC7B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oEAAkB,CAAC,gDAAmB,iCAAiC,gDAAgD;AACtI;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mEAAc;AAC7D;AACA,gBAAgB,gDAAmB,CAAC,2DAAS,IAAI,8EAA8E,SAAS,gDAAmB,CAAC,wEAAsB,IAAI;AACtL;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,CAAC,0BAA0B;AAC3B","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/htmlviewer/lib/index.js"],"sourcesContent":["/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module htmlviewer\n */\nimport { IFrame, ReactWidget, ToolbarButton, ToolbarButtonComponent, UseSignal } from '@jupyterlab/apputils';\nimport { ActivityMonitor } from '@jupyterlab/coreutils';\nimport { ABCWidgetFactory, DocumentWidget } from '@jupyterlab/docregistry';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { refreshIcon } from '@jupyterlab/ui-components';\nimport { Token } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport * as React from 'react';\n/**\n * The HTML viewer tracker token.\n */\nexport const IHTMLViewerTracker = new Token('@jupyterlab/htmlviewer:IHTMLViewerTracker');\n/**\n * The timeout to wait for change activity to have ceased before rendering.\n */\nconst RENDER_TIMEOUT = 1000;\n/**\n * The CSS class to add to the HTMLViewer Widget.\n */\nconst CSS_CLASS = 'jp-HTMLViewer';\n/**\n * A viewer widget for HTML documents.\n *\n * #### Notes\n * The iframed HTML document can pose a potential security risk,\n * since it can execute Javascript, and make same-origin requests\n * to the server, thereby executing arbitrary Javascript.\n *\n * Here, we sandbox the iframe so that it can't execute Javascript\n * or launch any popups. We allow one exception: 'allow-same-origin'\n * requests, so that local HTML documents can access CSS, images,\n * etc from the files system.\n */\nexport class HTMLViewer extends DocumentWidget {\n    /**\n     * Create a new widget for rendering HTML.\n     */\n    constructor(options) {\n        super(Object.assign(Object.assign({}, options), { content: new IFrame({ sandbox: ['allow-same-origin'] }) }));\n        this._renderPending = false;\n        this._parser = new DOMParser();\n        this._monitor = null;\n        this._objectUrl = '';\n        this._trustedChanged = new Signal(this);\n        this.translator = options.translator || nullTranslator;\n        this.content.addClass(CSS_CLASS);\n        void this.context.ready.then(() => {\n            this.update();\n            // Throttle the rendering rate of the widget.\n            this._monitor = new ActivityMonitor({\n                signal: this.context.model.contentChanged,\n                timeout: RENDER_TIMEOUT\n            });\n            this._monitor.activityStopped.connect(this.update, this);\n        });\n    }\n    /**\n     * Whether the HTML document is trusted. If trusted,\n     * it can execute Javascript in the iframe sandbox.\n     */\n    get trusted() {\n        return this.content.sandbox.indexOf('allow-scripts') !== -1;\n    }\n    set trusted(value) {\n        if (this.trusted === value) {\n            return;\n        }\n        if (value) {\n            this.content.sandbox = Private.trusted;\n        }\n        else {\n            this.content.sandbox = Private.untrusted;\n        }\n        // eslint-disable-next-line\n        this.content.url = this.content.url; // Force a refresh.\n        this._trustedChanged.emit(value);\n    }\n    /**\n     * Emitted when the trust state of the document changes.\n     */\n    get trustedChanged() {\n        return this._trustedChanged;\n    }\n    /**\n     * Dispose of resources held by the html viewer.\n     */\n    dispose() {\n        if (this._objectUrl) {\n            try {\n                URL.revokeObjectURL(this._objectUrl);\n            }\n            catch (error) {\n                /* no-op */\n            }\n        }\n        super.dispose();\n    }\n    /**\n     * Handle and update request.\n     */\n    onUpdateRequest() {\n        if (this._renderPending) {\n            return;\n        }\n        this._renderPending = true;\n        void this._renderModel().then(() => (this._renderPending = false));\n    }\n    /**\n     * Render HTML in IFrame into this widget's node.\n     */\n    async _renderModel() {\n        let data = this.context.model.toString();\n        data = await this._setBase(data);\n        // Set the new iframe url.\n        const blob = new Blob([data], { type: 'text/html' });\n        const oldUrl = this._objectUrl;\n        this._objectUrl = URL.createObjectURL(blob);\n        this.content.url = this._objectUrl;\n        // Release reference to any previous object url.\n        if (oldUrl) {\n            try {\n                URL.revokeObjectURL(oldUrl);\n            }\n            catch (error) {\n                /* no-op */\n            }\n        }\n        return;\n    }\n    /**\n     * Set a <base> element in the HTML string so that the iframe\n     * can correctly dereference relative links.\n     */\n    async _setBase(data) {\n        const doc = this._parser.parseFromString(data, 'text/html');\n        let base = doc.querySelector('base');\n        if (!base) {\n            base = doc.createElement('base');\n            doc.head.insertBefore(base, doc.head.firstChild);\n        }\n        const path = this.context.path;\n        const baseUrl = await this.context.urlResolver.getDownloadUrl(path);\n        // Set the base href, plus a fake name for the url of this\n        // document. The fake name doesn't really matter, as long\n        // as the document can dereference relative links to resources\n        // (e.g. CSS and scripts).\n        base.href = baseUrl;\n        base.target = '_self';\n        return doc.documentElement.innerHTML;\n    }\n}\n/**\n * A widget factory for HTMLViewers.\n */\nexport class HTMLViewerFactory extends ABCWidgetFactory {\n    /**\n     * Create a new widget given a context.\n     */\n    createNewWidget(context) {\n        return new HTMLViewer({ context });\n    }\n    /**\n     * Default factory for toolbar items to be added after the widget is created.\n     */\n    defaultToolbarFactory(widget) {\n        return [\n            // Make a refresh button for the toolbar.\n            {\n                name: 'refresh',\n                widget: ToolbarItems.createRefreshButton(widget, this.translator)\n            },\n            // Make a trust button for the toolbar.\n            {\n                name: 'trust',\n                widget: ToolbarItems.createTrustButton(widget, this.translator)\n            }\n        ];\n    }\n}\n/**\n * A namespace for toolbar items generator\n */\nexport var ToolbarItems;\n(function (ToolbarItems) {\n    /**\n     * Create the refresh button\n     *\n     * @param widget HTML viewer widget\n     * @param translator Application translator object\n     * @returns Toolbar item button\n     */\n    function createRefreshButton(widget, translator) {\n        const trans = (translator !== null && translator !== void 0 ? translator : nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: refreshIcon,\n            onClick: async () => {\n                if (!widget.context.model.dirty) {\n                    await widget.context.revert();\n                    widget.update();\n                }\n            },\n            tooltip: trans.__('Rerender HTML Document')\n        });\n    }\n    ToolbarItems.createRefreshButton = createRefreshButton;\n    /**\n     * Create the trust button\n     *\n     * @param document HTML viewer widget\n     * @param translator Application translator object\n     * @returns Toolbar item button\n     */\n    function createTrustButton(document, translator) {\n        return ReactWidget.create(React.createElement(Private.TrustButtonComponent, { htmlDocument: document, translator: translator }));\n    }\n    ToolbarItems.createTrustButton = createTrustButton;\n})(ToolbarItems || (ToolbarItems = {}));\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Sandbox exceptions for untrusted HTML.\n     */\n    Private.untrusted = [];\n    /**\n     * Sandbox exceptions for trusted HTML.\n     */\n    Private.trusted = ['allow-scripts'];\n    /**\n     * React component for a trusted button.\n     *\n     * This wraps the ToolbarButtonComponent and watches for trust changes.\n     */\n    function TrustButtonComponent(props) {\n        const translator = props.translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        return (React.createElement(UseSignal, { signal: props.htmlDocument.trustedChanged, initialSender: props.htmlDocument }, () => (React.createElement(ToolbarButtonComponent, { className: \"\", onClick: () => (props.htmlDocument.trusted = !props.htmlDocument.trusted), tooltip: trans.__(`Whether the HTML file is trusted.\nTrusting the file allows scripts to run in it,\nwhich may result in security risks.\nOnly enable for files you trust.`), label: props.htmlDocument.trusted\n                ? trans.__('Distrust HTML')\n                : trans.__('Trust HTML') }))));\n    }\n    Private.TrustButtonComponent = TrustButtonComponent;\n})(Private || (Private = {}));\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":""}