{"version":3,"file":"packages_kernel_lib_index_js.9f0db41.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACyB;AACC;AACI;AACL;;;;;;;;;;;;;;;;;;;ACL4B;AACV;AAC3C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qDAAM;AACnC;AACA;AACA,gBAAgB,kCAAkC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAA2B;AACnD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAA2B;AACnD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAA2B;AACnD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAA2B;AACnD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAA2B;AACnD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACvcwD;AAC2B;AAC1C;AACe;AACpB;AACe;AACnD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kEAAa;AACzC,4BAA4B,kEAAa;AACzC,kCAAkC,kEAAa;AAC/C,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,0BAA0B,8CAAK;AAC/B;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,0BAA0B,sFAAW;AACrC;AACA;AACA,0BAA0B,sFAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,yDAAU;AACvE;AACA,6BAA6B,oBAAoB,cAAc,SAAS;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,SAAS;AAC7F;AACA;AACA,4BAA4B,oFAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6BAA6B,+CAAe;AAC5C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;AACA,gBAAgB,qBAAqB;AACrC;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wEAAqB;AAC/C,CAAC,0BAA0B;;;;;;;;;;;;;;;;;;ACzLwB;AACR;AAC3C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uEAAoB;AACpD;AACA;AACA;AACA;AACA;AACA,oCAAoC,oDAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AClDA;AACA;AAC0C;AAC1C;AACA;AACA;AACO,qBAAqB,oDAAK;AACjC;AACA;AACA;AACO;AACP;AACA;AACA;AACO,yBAAyB,oDAAK","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/kernel/lib/index.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/kernel/lib/kernel.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/kernel/lib/kernels.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/kernel/lib/kernelspecs.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../packages/kernel/lib/tokens.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nexport * from './kernel';\nexport * from './kernels';\nexport * from './kernelspecs';\nexport * from './tokens';\n","import { KernelMessage } from '@jupyterlab/services';\nimport { Signal } from '@lumino/signaling';\n/**\n * A base kernel class handling basic kernel messaging.\n */\nexport class BaseKernel {\n    /**\n     * Construct a new BaseKernel.\n     *\n     * @param options The instantiation options for a BaseKernel.\n     */\n    constructor(options) {\n        this._history = [];\n        this._executionCount = 0;\n        this._isDisposed = false;\n        this._disposed = new Signal(this);\n        this._parentHeader = undefined;\n        this._parent = undefined;\n        const { id, name, location, sendMessage } = options;\n        this._id = id;\n        this._name = name;\n        this._location = location;\n        this._sendMessage = sendMessage;\n    }\n    /**\n     * A promise that is fulfilled when the kernel is ready.\n     */\n    get ready() {\n        return Promise.resolve();\n    }\n    /**\n     * Return whether the kernel is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * A signal emitted when the kernel is disposed.\n     */\n    get disposed() {\n        return this._disposed;\n    }\n    /**\n     * Get the kernel id\n     */\n    get id() {\n        return this._id;\n    }\n    /**\n     * Get the name of the kernel\n     */\n    get name() {\n        return this._name;\n    }\n    /**\n     * The location in the virtual filesystem from which the kernel was started.\n     */\n    get location() {\n        return this._location;\n    }\n    /**\n     * The current execution count\n     */\n    get executionCount() {\n        return this._executionCount;\n    }\n    /**\n     * Get the last parent header\n     */\n    get parentHeader() {\n        return this._parentHeader;\n    }\n    /**\n     * Get the last parent message (mimic ipykernel's get_parent)\n     */\n    get parent() {\n        return this._parent;\n    }\n    /**\n     * Dispose the kernel.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._disposed.emit(void 0);\n    }\n    /**\n     * Handle an incoming message from the client.\n     *\n     * @param msg The message to handle\n     */\n    async handleMessage(msg) {\n        this._busy(msg);\n        this._parent = msg;\n        const msgType = msg.header.msg_type;\n        switch (msgType) {\n            case 'kernel_info_request':\n                await this._kernelInfo(msg);\n                break;\n            case 'execute_request':\n                await this._execute(msg);\n                break;\n            case 'input_reply':\n                this.inputReply(msg.content);\n                break;\n            case 'inspect_request':\n                await this._inspect(msg);\n                break;\n            case 'is_complete_request':\n                await this._isCompleteRequest(msg);\n                break;\n            case 'complete_request':\n                await this._complete(msg);\n                break;\n            case 'history_request':\n                await this._historyRequest(msg);\n                break;\n            case 'comm_open':\n                await this.commOpen(msg);\n                break;\n            case 'comm_msg':\n                await this.commMsg(msg);\n                break;\n            case 'comm_close':\n                await this.commClose(msg);\n                break;\n            default:\n                break;\n        }\n        this._idle(msg);\n    }\n    /**\n     * Stream an event from the kernel\n     *\n     * @param parentHeader The parent header.\n     * @param content The stream content.\n     */\n    stream(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'stream',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `display_data` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The display_data content.\n     */\n    displayData(content, parentHeader = undefined) {\n        var _a, _b;\n        // Make sure metadata is always set\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        content.metadata = (_a = content.metadata) !== null && _a !== void 0 ? _a : {};\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'display_data',\n            // TODO: better handle this\n            session: (_b = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _b !== void 0 ? _b : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `input_request` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The input_request content.\n     */\n    inputRequest(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'stdin',\n            msgType: 'input_request',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send an `execute_result` message.\n     *\n     * @param parentHeader The parent header.\n     * @param content The execute result content.\n     */\n    publishExecuteResult(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'execute_result',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send an `error` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The error content.\n     */\n    publishExecuteError(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'error',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `update_display_data` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The update_display_data content.\n     */\n    updateDisplayData(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'update_display_data',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `clear_output` message to the client.\n     *\n     * @param parentHeader The parent header.\n     * @param content The clear_output content.\n     */\n    clearOutput(content, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: 'clear_output',\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a `comm` message to the client.\n     *\n     * @param .\n     */\n    handleComm(type, content, metadata, buffers, parentHeader = undefined) {\n        var _a;\n        const parentHeaderValue = typeof parentHeader !== 'undefined' ? parentHeader : this._parentHeader;\n        const message = KernelMessage.createMessage({\n            channel: 'iopub',\n            msgType: type,\n            // TODO: better handle this\n            session: (_a = parentHeaderValue === null || parentHeaderValue === void 0 ? void 0 : parentHeaderValue.session) !== null && _a !== void 0 ? _a : '',\n            parentHeader: parentHeaderValue,\n            content,\n            metadata,\n            buffers,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send an 'idle' status message.\n     *\n     * @param parent The parent message\n     */\n    _idle(parent) {\n        const message = KernelMessage.createMessage({\n            msgType: 'status',\n            session: parent.header.session,\n            parentHeader: parent.header,\n            channel: 'iopub',\n            content: {\n                execution_state: 'idle',\n            },\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send a 'busy' status message.\n     *\n     * @param parent The parent message.\n     */\n    _busy(parent) {\n        const message = KernelMessage.createMessage({\n            msgType: 'status',\n            session: parent.header.session,\n            parentHeader: parent.header,\n            channel: 'iopub',\n            content: {\n                execution_state: 'busy',\n            },\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle a kernel_info_request message\n     *\n     * @param parent The parent message.\n     */\n    async _kernelInfo(parent) {\n        const content = await this.kernelInfoRequest();\n        const message = KernelMessage.createMessage({\n            msgType: 'kernel_info_reply',\n            channel: 'shell',\n            session: parent.header.session,\n            parentHeader: parent.header,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle a `history_request` message\n     *\n     * @param msg The parent message.\n     */\n    async _historyRequest(msg) {\n        const historyMsg = msg;\n        const message = KernelMessage.createMessage({\n            msgType: 'history_reply',\n            channel: 'shell',\n            parentHeader: historyMsg.header,\n            session: msg.header.session,\n            content: {\n                status: 'ok',\n                history: this._history,\n            },\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Send an `execute_input` message.\n     *\n     * @param msg The parent message.\n     */\n    _executeInput(msg) {\n        const parent = msg;\n        const code = parent.content.code;\n        const message = KernelMessage.createMessage({\n            msgType: 'execute_input',\n            parentHeader: parent.header,\n            channel: 'iopub',\n            session: msg.header.session,\n            content: {\n                code,\n                execution_count: this._executionCount,\n            },\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle an execute_request message.\n     *\n     * @param msg The parent message.\n     */\n    async _execute(msg) {\n        const executeMsg = msg;\n        const content = executeMsg.content;\n        if (content.store_history) {\n            this._executionCount++;\n        }\n        // TODO: handle differently\n        this._parentHeader = executeMsg.header;\n        this._executeInput(executeMsg);\n        if (content.store_history) {\n            this._history.push([0, 0, content.code]);\n        }\n        const reply = await this.executeRequest(executeMsg.content);\n        const message = KernelMessage.createMessage({\n            msgType: 'execute_reply',\n            channel: 'shell',\n            parentHeader: executeMsg.header,\n            session: msg.header.session,\n            content: reply,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle an complete_request message\n     *\n     * @param msg The parent message.\n     */\n    async _complete(msg) {\n        const completeMsg = msg;\n        const content = await this.completeRequest(completeMsg.content);\n        const message = KernelMessage.createMessage({\n            msgType: 'complete_reply',\n            parentHeader: completeMsg.header,\n            channel: 'shell',\n            session: msg.header.session,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle an inspect_request message\n     *\n     * @param msg The parent message.\n     */\n    async _inspect(msg) {\n        const inspectMsg = msg;\n        const content = await this.inspectRequest(inspectMsg.content);\n        const message = KernelMessage.createMessage({\n            msgType: 'inspect_reply',\n            parentHeader: inspectMsg.header,\n            channel: 'shell',\n            session: msg.header.session,\n            content,\n        });\n        this._sendMessage(message);\n    }\n    /**\n     * Handle an is_complete_request message\n     *\n     * @param msg The parent message.\n     */\n    async _isCompleteRequest(msg) {\n        const isCompleteMsg = msg;\n        const content = await this.isCompleteRequest(isCompleteMsg.content);\n        const message = KernelMessage.createMessage({\n            msgType: 'is_complete_reply',\n            parentHeader: isCompleteMsg.header,\n            channel: 'shell',\n            session: msg.header.session,\n            content,\n        });\n        this._sendMessage(message);\n    }\n}\n","import { ObservableMap } from '@jupyterlab/observables';\nimport { deserialize, serialize } from '@jupyterlab/services/lib/kernel/serialize';\nimport { UUID } from '@lumino/coreutils';\nimport { Server as WebSocketServer } from 'mock-socket';\nimport { Mutex } from 'async-mutex';\nimport { PageConfig } from '@jupyterlab/coreutils';\n/**\n * A class to handle requests to /api/kernels\n */\nexport class Kernels {\n    /**\n     * Construct a new Kernels\n     *\n     * @param options The instantiation options\n     */\n    constructor(options) {\n        this._kernels = new ObservableMap();\n        this._clients = new ObservableMap();\n        this._kernelClients = new ObservableMap();\n        const { kernelspecs } = options;\n        this._kernelspecs = kernelspecs;\n    }\n    /**\n     * Start a new kernel.\n     *\n     * @param options The kernel start options.\n     */\n    async startNew(options) {\n        const { id, name, location } = options;\n        const factory = this._kernelspecs.factories.get(name);\n        // bail if there is no factory associated with the requested kernel\n        if (!factory) {\n            return { id, name };\n        }\n        // create a synchronization mechanism to allow only one message\n        // to be processed at a time\n        const mutex = new Mutex();\n        // hook a new client to a kernel\n        const hook = (kernelId, clientId, socket) => {\n            var _a;\n            const kernel = this._kernels.get(kernelId);\n            if (!kernel) {\n                throw Error(`No kernel ${kernelId}`);\n            }\n            this._clients.set(clientId, socket);\n            (_a = this._kernelClients.get(kernelId)) === null || _a === void 0 ? void 0 : _a.add(clientId);\n            const processMsg = async (msg) => {\n                await mutex.runExclusive(async () => {\n                    await kernel.handleMessage(msg);\n                });\n            };\n            socket.on('message', async (message) => {\n                let msg;\n                if (message instanceof ArrayBuffer) {\n                    message = new Uint8Array(message).buffer;\n                    msg = deserialize(message);\n                }\n                else if (typeof message === 'string') {\n                    msg = deserialize(message);\n                }\n                else {\n                    return;\n                }\n                // TODO Find a better solution for this?\n                // input-reply is asynchronous, must not be processed like other messages\n                if (msg.header.msg_type === 'input_reply') {\n                    kernel.handleMessage(msg);\n                }\n                else {\n                    void processMsg(msg);\n                }\n            });\n            const removeClient = () => {\n                var _a;\n                this._clients.delete(clientId);\n                (_a = this._kernelClients.get(kernelId)) === null || _a === void 0 ? void 0 : _a.delete(clientId);\n            };\n            kernel.disposed.connect(removeClient);\n            // TODO: check whether this is called\n            // https://github.com/thoov/mock-socket/issues/298\n            // https://github.com/jupyterlab/jupyterlab/blob/6bc884a7a8ed73c615ce72ba097bdb790482b5bf/packages/services/src/kernel/default.ts#L1245\n            socket.onclose = removeClient;\n        };\n        // ensure kernel id\n        const kernelId = id !== null && id !== void 0 ? id : UUID.uuid4();\n        // There is one server per kernel which handles multiple clients\n        const kernelUrl = `${Kernels.WS_BASE_URL}api/kernels/${kernelId}/channels`;\n        const runningKernel = this._kernels.get(kernelId);\n        if (runningKernel) {\n            return {\n                id: runningKernel.id,\n                name: runningKernel.name,\n            };\n        }\n        // start the kernel\n        const sendMessage = (msg) => {\n            const clientId = msg.header.session;\n            const socket = this._clients.get(clientId);\n            if (!socket) {\n                console.warn(`Trying to send message on removed socket for kernel ${kernelId}`);\n                return;\n            }\n            const message = serialize(msg);\n            // process iopub messages\n            if (msg.channel === 'iopub') {\n                const clients = this._kernelClients.get(kernelId);\n                clients === null || clients === void 0 ? void 0 : clients.forEach((id) => {\n                    var _a;\n                    (_a = this._clients.get(id)) === null || _a === void 0 ? void 0 : _a.send(message);\n                });\n                return;\n            }\n            socket.send(message);\n        };\n        const kernel = await factory({\n            id: kernelId,\n            sendMessage,\n            name,\n            location,\n        });\n        await kernel.ready;\n        this._kernels.set(kernelId, kernel);\n        this._kernelClients.set(kernelId, new Set());\n        // create the websocket server for the kernel\n        const wsServer = new WebSocketServer(kernelUrl);\n        wsServer.on('connection', (socket) => {\n            var _a;\n            const url = new URL(socket.url);\n            const clientId = (_a = url.searchParams.get('session_id')) !== null && _a !== void 0 ? _a : '';\n            hook(kernelId, clientId, socket);\n        });\n        // clean up closed connection\n        wsServer.on('close', () => {\n            this._clients.keys().forEach((clientId) => {\n                var _a;\n                const socket = this._clients.get(clientId);\n                if ((socket === null || socket === void 0 ? void 0 : socket.readyState) === WebSocket.CLOSED) {\n                    this._clients.delete(clientId);\n                    (_a = this._kernelClients.get(kernelId)) === null || _a === void 0 ? void 0 : _a.delete(clientId);\n                }\n            });\n        });\n        // cleanup on kernel shutdown\n        kernel.disposed.connect(() => {\n            wsServer.close();\n            this._kernels.delete(kernelId);\n            this._kernelClients.delete(kernelId);\n        });\n        return {\n            id: kernel.id,\n            name: kernel.name,\n        };\n    }\n    /**\n     * Restart a kernel.\n     *\n     * @param kernelId The kernel id.\n     */\n    async restart(kernelId) {\n        const kernel = this._kernels.get(kernelId);\n        if (!kernel) {\n            throw Error(`Kernel ${kernelId} does not exist`);\n        }\n        const { id, name, location } = kernel;\n        kernel.dispose();\n        return this.startNew({ id, name, location });\n    }\n    /**\n     * Shut down a kernel.\n     *\n     * @param id The kernel id.\n     */\n    async shutdown(id) {\n        var _a;\n        (_a = this._kernels.delete(id)) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n}\n/**\n * A namespace for Kernels statics.\n */\n(function (Kernels) {\n    /**\n     * The base url for the Kernels manager\n     */\n    Kernels.WS_BASE_URL = PageConfig.getBaseUrl().replace(/^http/, 'ws');\n})(Kernels || (Kernels = {}));\n","import { PageConfig } from '@jupyterlab/coreutils';\nimport { FALLBACK_KERNEL } from './tokens';\n/**\n * A class to handle requests to /api/kernelspecs\n */\nexport class KernelSpecs {\n    constructor() {\n        this._specs = new Map();\n        this._factories = new Map();\n    }\n    /**\n     * Get the kernel specs.\n     */\n    get specs() {\n        if (this._specs.size === 0) {\n            return null;\n        }\n        return {\n            default: this.defaultKernelName,\n            kernelspecs: Object.fromEntries(this._specs),\n        };\n    }\n    /**\n     * Get the default kernel name.\n     */\n    get defaultKernelName() {\n        let defaultKernelName = PageConfig.getOption('defaultKernelName');\n        if (!defaultKernelName && this._specs.size) {\n            const keys = Array.from(this._specs.keys());\n            keys.sort();\n            defaultKernelName = keys[0];\n        }\n        return defaultKernelName || FALLBACK_KERNEL;\n    }\n    /**\n     * Get the kernel factories for the current kernels.\n     */\n    get factories() {\n        return this._factories;\n    }\n    /**\n     * Register a new kernel.\n     *\n     * @param options The options to register a new kernel.\n     */\n    register(options) {\n        const { spec, create } = options;\n        this._specs.set(spec.name, spec);\n        this._factories.set(spec.name, create);\n    }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/**\n * The token for the kernels service.\n */\nexport const IKernels = new Token('@jupyterlite/kernel:IKernels');\n/**\n * The kernel name of last resort.\n */\nexport const FALLBACK_KERNEL = 'javascript';\n/**\n * The token for the kernel spec service.\n */\nexport const IKernelSpecs = new Token('@jupyterlite/kernel:IKernelSpecs');\n"],"names":[],"sourceRoot":""}