{"version":3,"file":"node_modules_jupyterlab_documentsearch-extension_lib_index_js-_57671.f9eb561.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACoD;AACG;AACwG;AAChG;AACT;AACtD;AACA;AACA;AACA,eAAe,8DAAS,EAAE,+EAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+EAAuB;AACrC,eAAe,gEAAW;AAC1B,eAAe,iEAAe,EAAE,yEAAgB;AAChD;AACA;AACA;AACA;AACA;AACA,6BAA6B,8EAAsB;AACnD;AACA,uDAAuD,8EAAsB;AAC7E,yDAAyD,gFAAwB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sEAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iEAAe,mCAAmC,EAAC;AACnD","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/documentsearch-extension/lib/index.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module documentsearch-extension\n */\nimport { ILabShell } from '@jupyterlab/application';\nimport { ICommandPalette } from '@jupyterlab/apputils';\nimport { CodeMirrorSearchProvider, ISearchProviderRegistry, NotebookSearchProvider, SearchInstance, SearchProviderRegistry } from '@jupyterlab/documentsearch';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { ITranslator } from '@jupyterlab/translation';\nconst SEARCHABLE_CLASS = 'jp-mod-searchable';\nconst labShellWidgetListener = {\n    id: '@jupyterlab/documentsearch:labShellWidgetListener',\n    requires: [ILabShell, ISearchProviderRegistry],\n    autoStart: true,\n    activate: (app, labShell, registry) => {\n        // If a given widget is searchable, apply the searchable class.\n        // If it's not searchable, remove the class.\n        const transformWidgetSearchability = (widget) => {\n            if (!widget) {\n                return;\n            }\n            const providerForWidget = registry.getProviderForWidget(widget);\n            if (providerForWidget) {\n                widget.addClass(SEARCHABLE_CLASS);\n            }\n            if (!providerForWidget) {\n                widget.removeClass(SEARCHABLE_CLASS);\n            }\n        };\n        // Update searchability of the active widget when the registry\n        // changes, in case a provider for the current widget was added\n        // or removed\n        registry.changed.connect(() => transformWidgetSearchability(labShell.activeWidget));\n        // Apply the searchable class only to the active widget if it is actually\n        // searchable. Remove the searchable class from a widget when it's\n        // no longer active.\n        labShell.activeChanged.connect((_, args) => {\n            const oldWidget = args.oldValue;\n            if (oldWidget) {\n                oldWidget.removeClass(SEARCHABLE_CLASS);\n            }\n            transformWidgetSearchability(args.newValue);\n        });\n    }\n};\n/**\n * Initialization data for the document-search extension.\n */\nconst extension = {\n    id: '@jupyterlab/documentsearch:plugin',\n    provides: ISearchProviderRegistry,\n    requires: [ITranslator],\n    optional: [ICommandPalette, ISettingRegistry],\n    autoStart: true,\n    activate: (app, translator, palette, settingRegistry) => {\n        const trans = translator.load('jupyterlab');\n        let searchDebounceTime = 500;\n        // Create registry, retrieve all default providers\n        const registry = new SearchProviderRegistry();\n        // Register default implementations of the Notebook and CodeMirror search providers\n        registry.register('jp-notebookSearchProvider', NotebookSearchProvider);\n        registry.register('jp-codeMirrorSearchProvider', CodeMirrorSearchProvider);\n        const activeSearches = new Map();\n        const startCommand = 'documentsearch:start';\n        const startReplaceCommand = 'documentsearch:startWithReplace';\n        const nextCommand = 'documentsearch:highlightNext';\n        const prevCommand = 'documentsearch:highlightPrevious';\n        if (settingRegistry) {\n            const loadSettings = settingRegistry.load('@jupyterlab/documentsearch-extension:plugin');\n            const updateSettings = (settings) => {\n                searchDebounceTime = settings.get('searchDebounceTime')\n                    .composite;\n            };\n            Promise.all([loadSettings, app.restored])\n                .then(([settings]) => {\n                updateSettings(settings);\n                settings.changed.connect(settings => {\n                    updateSettings(settings);\n                });\n            })\n                .catch((reason) => {\n                console.error(reason.message);\n            });\n        }\n        const currentWidgetHasSearchProvider = () => {\n            const currentWidget = app.shell.currentWidget;\n            if (!currentWidget) {\n                return false;\n            }\n            return registry.getProviderForWidget(currentWidget) !== undefined;\n        };\n        const getCurrentWidgetSearchInstance = () => {\n            const currentWidget = app.shell.currentWidget;\n            if (!currentWidget) {\n                return;\n            }\n            const widgetId = currentWidget.id;\n            let searchInstance = activeSearches.get(widgetId);\n            if (!searchInstance) {\n                const searchProvider = registry.getProviderForWidget(currentWidget);\n                if (!searchProvider) {\n                    return;\n                }\n                searchInstance = new SearchInstance(currentWidget, searchProvider, translator, searchDebounceTime);\n                activeSearches.set(widgetId, searchInstance);\n                // find next and previous are now enabled\n                app.commands.notifyCommandChanged();\n                searchInstance.disposed.connect(() => {\n                    activeSearches.delete(widgetId);\n                    // find next and previous are now not enabled\n                    app.commands.notifyCommandChanged();\n                });\n            }\n            return searchInstance;\n        };\n        app.commands.addCommand(startCommand, {\n            label: trans.__('Find…'),\n            isEnabled: currentWidgetHasSearchProvider,\n            execute: args => {\n                const searchInstance = getCurrentWidgetSearchInstance();\n                if (searchInstance) {\n                    const searchText = args['searchText'];\n                    if (searchText) {\n                        searchInstance.setSearchText(searchText);\n                    }\n                    searchInstance.focusInput();\n                }\n            }\n        });\n        app.commands.addCommand(startReplaceCommand, {\n            label: trans.__('Find and Replace…'),\n            isEnabled: currentWidgetHasSearchProvider,\n            execute: args => {\n                const searchInstance = getCurrentWidgetSearchInstance();\n                if (searchInstance) {\n                    const searchText = args['searchText'];\n                    if (searchText) {\n                        searchInstance.setSearchText(searchText);\n                    }\n                    const replaceText = args['replaceText'];\n                    if (replaceText) {\n                        searchInstance.setReplaceText(replaceText);\n                    }\n                    searchInstance.showReplace();\n                    searchInstance.focusInput();\n                }\n            }\n        });\n        app.commands.addCommand(nextCommand, {\n            label: trans.__('Find Next'),\n            isEnabled: () => {\n                const currentWidget = app.shell.currentWidget;\n                if (!currentWidget) {\n                    return false;\n                }\n                return activeSearches.has(currentWidget.id);\n            },\n            execute: async () => {\n                const currentWidget = app.shell.currentWidget;\n                if (!currentWidget) {\n                    return;\n                }\n                const instance = activeSearches.get(currentWidget.id);\n                if (!instance) {\n                    return;\n                }\n                await instance.provider.highlightNext();\n                instance.updateIndices();\n            }\n        });\n        app.commands.addCommand(prevCommand, {\n            label: trans.__('Find Previous'),\n            isEnabled: () => {\n                const currentWidget = app.shell.currentWidget;\n                if (!currentWidget) {\n                    return false;\n                }\n                return activeSearches.has(currentWidget.id);\n            },\n            execute: async () => {\n                const currentWidget = app.shell.currentWidget;\n                if (!currentWidget) {\n                    return;\n                }\n                const instance = activeSearches.get(currentWidget.id);\n                if (!instance) {\n                    return;\n                }\n                await instance.provider.highlightPrevious();\n                instance.updateIndices();\n            }\n        });\n        // Add the command to the palette.\n        if (palette) {\n            palette.addItem({\n                command: startCommand,\n                category: trans.__('Main Area')\n            });\n            palette.addItem({\n                command: nextCommand,\n                category: trans.__('Main Area')\n            });\n            palette.addItem({\n                command: prevCommand,\n                category: trans.__('Main Area')\n            });\n        }\n        // Provide the registry to the system.\n        return registry;\n    }\n};\nexport default [extension, labShellWidgetListener];\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":""}