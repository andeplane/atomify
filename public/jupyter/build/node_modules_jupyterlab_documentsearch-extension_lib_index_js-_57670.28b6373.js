"use strict";
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["node_modules_jupyterlab_documentsearch-extension_lib_index_js-_57670"],{

/***/ 24212:
/*!*************************************************************************!*\
  !*** ../node_modules/@jupyterlab/documentsearch-extension/lib/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/application */ 63109);
/* harmony import */ var _jupyterlab_application__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/apputils */ 94367);
/* harmony import */ var _jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jupyterlab/documentsearch */ 49506);
/* harmony import */ var _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @jupyterlab/settingregistry */ 32421);
/* harmony import */ var _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlab/translation */ 13790);
/* harmony import */ var _jupyterlab_translation__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_4__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
/**
 * @packageDocumentation
 * @module documentsearch-extension
 */





const SEARCHABLE_CLASS = 'jp-mod-searchable';
const labShellWidgetListener = {
    id: '@jupyterlab/documentsearch:labShellWidgetListener',
    requires: [_jupyterlab_application__WEBPACK_IMPORTED_MODULE_0__.ILabShell, _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2__.ISearchProviderRegistry],
    autoStart: true,
    activate: (app, labShell, registry) => {
        // If a given widget is searchable, apply the searchable class.
        // If it's not searchable, remove the class.
        const transformWidgetSearchability = (widget) => {
            if (!widget) {
                return;
            }
            const providerForWidget = registry.getProviderForWidget(widget);
            if (providerForWidget) {
                widget.addClass(SEARCHABLE_CLASS);
            }
            if (!providerForWidget) {
                widget.removeClass(SEARCHABLE_CLASS);
            }
        };
        // Update searchability of the active widget when the registry
        // changes, in case a provider for the current widget was added
        // or removed
        registry.changed.connect(() => transformWidgetSearchability(labShell.activeWidget));
        // Apply the searchable class only to the active widget if it is actually
        // searchable. Remove the searchable class from a widget when it's
        // no longer active.
        labShell.activeChanged.connect((_, args) => {
            const oldWidget = args.oldValue;
            if (oldWidget) {
                oldWidget.removeClass(SEARCHABLE_CLASS);
            }
            transformWidgetSearchability(args.newValue);
        });
    }
};
/**
 * Initialization data for the document-search extension.
 */
const extension = {
    id: '@jupyterlab/documentsearch:plugin',
    provides: _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2__.ISearchProviderRegistry,
    requires: [_jupyterlab_translation__WEBPACK_IMPORTED_MODULE_4__.ITranslator],
    optional: [_jupyterlab_apputils__WEBPACK_IMPORTED_MODULE_1__.ICommandPalette, _jupyterlab_settingregistry__WEBPACK_IMPORTED_MODULE_3__.ISettingRegistry],
    autoStart: true,
    activate: (app, translator, palette, settingRegistry) => {
        const trans = translator.load('jupyterlab');
        let searchDebounceTime = 500;
        // Create registry, retrieve all default providers
        const registry = new _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2__.SearchProviderRegistry();
        // Register default implementations of the Notebook and CodeMirror search providers
        registry.register('jp-notebookSearchProvider', _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2__.NotebookSearchProvider);
        registry.register('jp-codeMirrorSearchProvider', _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2__.CodeMirrorSearchProvider);
        const activeSearches = new Map();
        const startCommand = 'documentsearch:start';
        const startReplaceCommand = 'documentsearch:startWithReplace';
        const nextCommand = 'documentsearch:highlightNext';
        const prevCommand = 'documentsearch:highlightPrevious';
        if (settingRegistry) {
            const loadSettings = settingRegistry.load('@jupyterlab/documentsearch-extension:plugin');
            const updateSettings = (settings) => {
                searchDebounceTime = settings.get('searchDebounceTime')
                    .composite;
            };
            Promise.all([loadSettings, app.restored])
                .then(([settings]) => {
                updateSettings(settings);
                settings.changed.connect(settings => {
                    updateSettings(settings);
                });
            })
                .catch((reason) => {
                console.error(reason.message);
            });
        }
        const currentWidgetHasSearchProvider = () => {
            const currentWidget = app.shell.currentWidget;
            if (!currentWidget) {
                return false;
            }
            return registry.getProviderForWidget(currentWidget) !== undefined;
        };
        const getCurrentWidgetSearchInstance = () => {
            const currentWidget = app.shell.currentWidget;
            if (!currentWidget) {
                return;
            }
            const widgetId = currentWidget.id;
            let searchInstance = activeSearches.get(widgetId);
            if (!searchInstance) {
                const searchProvider = registry.getProviderForWidget(currentWidget);
                if (!searchProvider) {
                    return;
                }
                searchInstance = new _jupyterlab_documentsearch__WEBPACK_IMPORTED_MODULE_2__.SearchInstance(currentWidget, searchProvider, translator, searchDebounceTime);
                activeSearches.set(widgetId, searchInstance);
                // find next and previous are now enabled
                app.commands.notifyCommandChanged();
                searchInstance.disposed.connect(() => {
                    activeSearches.delete(widgetId);
                    // find next and previous are now not enabled
                    app.commands.notifyCommandChanged();
                });
            }
            return searchInstance;
        };
        app.commands.addCommand(startCommand, {
            label: trans.__('Find…'),
            isEnabled: currentWidgetHasSearchProvider,
            execute: args => {
                const searchInstance = getCurrentWidgetSearchInstance();
                if (searchInstance) {
                    const searchText = args['searchText'];
                    if (searchText) {
                        searchInstance.setSearchText(searchText);
                    }
                    searchInstance.focusInput();
                }
            }
        });
        app.commands.addCommand(startReplaceCommand, {
            label: trans.__('Find and Replace…'),
            isEnabled: currentWidgetHasSearchProvider,
            execute: args => {
                const searchInstance = getCurrentWidgetSearchInstance();
                if (searchInstance) {
                    const searchText = args['searchText'];
                    if (searchText) {
                        searchInstance.setSearchText(searchText);
                    }
                    const replaceText = args['replaceText'];
                    if (replaceText) {
                        searchInstance.setReplaceText(replaceText);
                    }
                    searchInstance.showReplace();
                    searchInstance.focusInput();
                }
            }
        });
        app.commands.addCommand(nextCommand, {
            label: trans.__('Find Next'),
            isEnabled: () => {
                const currentWidget = app.shell.currentWidget;
                if (!currentWidget) {
                    return false;
                }
                return activeSearches.has(currentWidget.id);
            },
            execute: async () => {
                const currentWidget = app.shell.currentWidget;
                if (!currentWidget) {
                    return;
                }
                const instance = activeSearches.get(currentWidget.id);
                if (!instance) {
                    return;
                }
                await instance.provider.highlightNext();
                instance.updateIndices();
            }
        });
        app.commands.addCommand(prevCommand, {
            label: trans.__('Find Previous'),
            isEnabled: () => {
                const currentWidget = app.shell.currentWidget;
                if (!currentWidget) {
                    return false;
                }
                return activeSearches.has(currentWidget.id);
            },
            execute: async () => {
                const currentWidget = app.shell.currentWidget;
                if (!currentWidget) {
                    return;
                }
                const instance = activeSearches.get(currentWidget.id);
                if (!instance) {
                    return;
                }
                await instance.provider.highlightPrevious();
                instance.updateIndices();
            }
        });
        // Add the command to the palette.
        if (palette) {
            palette.addItem({
                command: startCommand,
                category: trans.__('Main Area')
            });
            palette.addItem({
                command: nextCommand,
                category: trans.__('Main Area')
            });
            palette.addItem({
                command: prevCommand,
                category: trans.__('Main Area')
            });
        }
        // Provide the registry to the system.
        return registry;
    }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([extension, labShellWidgetListener]);
//# sourceMappingURL=index.js.map

/***/ })

}]);
//# sourceMappingURL=node_modules_jupyterlab_documentsearch-extension_lib_index_js-_57670.28b6373.js.map